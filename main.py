import time
import signal
import sys
import threading
import os
import io
import base64
from datetime import datetime, timedelta
from flask import Flask, render_template, jsonify, redirect, url_for, flash, request, send_file

# –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –∏–∑ .env —Ñ–∞–π–ª–∞, –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
from load_dotenv import load_dotenv
load_dotenv()

from logger import logger
from scheduler import SensorTowerScheduler
from config import APP_ID, SCHEDULE_HOUR, SCHEDULE_MINUTE, TELEGRAM_BOT_TOKEN, TELEGRAM_CHANNEL_ID
from history_api import HistoryAPI
from routes.history_routes import history_bp
from routes.altseason_routes import altseason_bp
from json_rank_reader import get_rank_from_json, get_latest_rank_date

# Create Flask app
app = Flask(__name__)
# –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è SESSION_SECRET –¥–ª—è secret_key –∏–ª–∏ —Ñ–æ–ª–±—ç–∫
app.secret_key = os.environ.get("SESSION_SECRET", "sensortower_bot_secret")

# –î–æ–±–∞–≤–ª—è–µ–º —Ñ–∏–ª—å—Ç—Ä now() –¥–ª—è —à–∞–±–ª–æ–Ω–æ–≤
@app.template_filter('now')
def template_now(_=None):
    return datetime.now()

# –î–æ–±–∞–≤–ª—è–µ–º —Ñ–∏–ª—å—Ç—Ä –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è timestamp –≤ —á–∏—Ç–∞–µ–º—É—é –¥–∞—Ç—É
@app.template_filter('timestampToDate')
def timestamp_to_date(timestamp):
    if not timestamp:
        return "N/A"
    try:
        # –ï—Å–ª–∏ timestamp –ø–µ—Ä–µ–¥–∞–Ω –∫–∞–∫ —Å—Ç—Ä–æ–∫–∞, –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –µ–µ –≤ —á–∏—Å–ª–æ
        if isinstance(timestamp, str):
            timestamp = float(timestamp)
        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º timestamp –≤ —á–∏—Ç–∞–µ–º—É—é –¥–∞—Ç—É
        return datetime.fromtimestamp(timestamp).strftime('%Y-%m-%d %H:%M:%S')
    except Exception:
        return timestamp  # –í —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∏—Å—Ö–æ–¥–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ

# –î–æ–±–∞–≤–ª—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é now() –¥–ª—è —à–∞–±–ª–æ–Ω–æ–≤
@app.context_processor
def utility_processor():
    def now():
        return datetime.now()
    return dict(now=now)

# –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º Blueprint'—ã
app.register_blueprint(history_bp)
app.register_blueprint(altseason_bp)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
scheduler = None
last_scrape_data = None
last_scrape_time = None
last_fear_greed_data = None
last_fear_greed_time = None
last_altseason_data = None
last_altseason_time = None

# –ü—Ä–æ—Å—Ç–æ–µ –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è Market Breadth –¥–∞–Ω–Ω—ã—Ö
market_breadth_cache = {
    'data': None,
    'timestamp': 0,
    'loading': False
}

def get_current_rank():
    """Get current rank from manual file or JSON file"""
    try:
        # Check if manual rank file exists
        if os.path.exists('manual_rank.txt'):
            with open('manual_rank.txt', 'r') as f:
                manual_rank = f.read().strip()
                if manual_rank and manual_rank.isdigit():
                    return int(manual_rank)
        
        # Read from JSON file
        json_rank = get_rank_from_json()
        if json_rank is not None:
            return json_rank
        
        # Return None if no data available
        return None
    except Exception:
        return None

def start_scheduler_thread():
    """Start the scheduler in a separate thread"""
    global scheduler
    scheduler = SensorTowerScheduler()
    success = scheduler.start()
    if not success:
        logger.error("Failed to start the scheduler")
    return success

def signal_handler(sig, frame):
    """Handle SIGINT (Ctrl+C) signal to gracefully shut down the application"""
    logger.info("Shutting down SensorTower bot...")
    if scheduler:
        scheduler.stop()
    sys.exit(0)

@app.route('/')
def index():
    """Render the home page"""
    global last_scrape_data, last_scrape_time, last_fear_greed_data, last_fear_greed_time, last_altseason_data, last_altseason_time
    
    # Check if scheduler is running
    # –ë–æ—Ç —Å—á–∏—Ç–∞–µ–º —Ä–∞–±–æ—Ç–∞—é—â–∏–º, –µ—Å–ª–∏ –æ–±—ä–µ–∫—Ç scheduler —Å—É—â–µ—Å—Ç–≤—É–µ—Ç,
    # —Ç–∞–∫ –∫–∞–∫ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ Telegram –≤—Å–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
    status = "running" if scheduler else "error"
    status_text = "Running" if status == "running" else "Error"
    status_class = "success" if status == "running" else "danger"
    
    # Check if Telegram is configured
    telegram_configured = bool(TELEGRAM_BOT_TOKEN and TELEGRAM_CHANNEL_ID)
    
    # Calculate next run time
    next_run = "Not scheduled"
    if scheduler:
        # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –≤—Ä–µ–º—è —Å–ª–µ–¥—É—é—â–µ–≥–æ –∑–∞–ø—É—Å–∫–∞ (5:01 UTC = 8:01 MSK)
        now = datetime.now()
        next_scheduled = now.replace(hour=5, minute=1, second=0, microsecond=0)
        
        # –ï—Å–ª–∏ –≤—Ä–µ–º—è —É–∂–µ –ø—Ä–æ—à–ª–æ —Å–µ–≥–æ–¥–Ω—è, –ø–ª–∞–Ω–∏—Ä—É–µ–º –Ω–∞ –∑–∞–≤—Ç—Ä–∞
        if next_scheduled <= now:
            next_scheduled += timedelta(days=1)
            
        next_run = next_scheduled.strftime("%Y-%m-%d %H:%M:%S")
    
    schedule_time = f"{SCHEDULE_HOUR:02d}:{SCHEDULE_MINUTE:02d}"
    
    # Get categories from last scrape if available
    categories = []
    if last_scrape_data and "categories" in last_scrape_data:
        categories = last_scrape_data["categories"]
    
    return render_template('index.html', 
                          status=status,
                          status_text=status_text,
                          status_class=status_class,
                          app_id=APP_ID,
                          telegram_configured=telegram_configured,
                          next_run=next_run,
                          schedule_time=schedule_time,
                          last_scrape_time=last_scrape_time,
                          categories=categories,
                          last_fear_greed_data=last_fear_greed_data,
                          last_fear_greed_time=last_fear_greed_time,
                          last_altseason_data=last_altseason_data,
                          last_altseason_time=last_altseason_time,
                          current_rank=get_current_rank())

@app.route('/test-telegram')
def test_telegram():
    """Test the Telegram connection"""
    if not scheduler:
        return jsonify({"status": "error", "message": "Scheduler not initialized"}), 500
        
    try:
        # Test the Telegram connection using the bot's test_connection method
        telegram_bot = scheduler.telegram_bot
        if telegram_bot.test_connection():
            # If test is successful, try to send a test message
            test_msg = (
                "üß™ Test message from SensorTower Bot\n\n"
                "This message was sent to verify the bot is working correctly.\n"
                f"Date and time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
            )
            
            if telegram_bot.send_message(test_msg):
                return jsonify({
                    "status": "success", 
                    "message": "Telegram connection successful and test message sent!"
                })
            else:
                return jsonify({
                    "status": "warning", 
                    "message": "Connected to Telegram API, but failed to send test message. Check your channel ID."
                }), 200
        else:
            return jsonify({
                "status": "error", 
                "message": "Failed to connect to Telegram API. Check your bot token."
            }), 400
    except Exception as e:
        logger.error(f"Error testing Telegram connection: {str(e)}")
        return jsonify({"status": "error", "message": f"Error: {str(e)}"}), 500



@app.route('/trigger-scrape')
def trigger_scrape():
    """Manually trigger a scrape job"""
    global last_scrape_data, last_scrape_time
    
    if not scheduler:
        return jsonify({"status": "error", "message": "Scheduler not initialized"}), 500
    
    try:
        # Get force_send parameter (default is False)
        force_send = request.args.get('force', 'false').lower() == 'true'
        
        # Run the scraping job using the new run_now method
        if force_send:
            logger.info("Manual trigger with force_send=True")
            success = scheduler.run_now(force_send=True)
        else:
            logger.info("Manual trigger with normal change detection")
            success = scheduler.run_now(force_send=False)
        
        if success:
            # Store the scraped data for display
            last_scrape_data = scheduler.scraper.last_scrape_data
            last_scrape_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
            if force_send:
                flash("Scraping job completed successfully! Message sent regardless of changes.", "success")
            else:
                flash("Scraping job completed successfully! Message sent only if ranking changed.", "success")
                
            return redirect(url_for('index'))
        else:
            return jsonify({"status": "error", "message": "Scraping job failed"}), 500
    except Exception as e:
        logger.error(f"Error triggering manual scrape: {str(e)}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/logs')
def view_logs():
    """View the application logs"""
    from config import LOG_FILE
    
    # Read the last 100 lines of the log file
    log_content = []
    try:
        with open(LOG_FILE, 'r') as f:
            log_content = f.readlines()[-100:]
    except Exception as e:
        logger.error(f"Error reading log file: {str(e)}")
        log_content = [f"Error reading log file: {str(e)}"]
    
    return render_template('logs.html', logs=log_content)

@app.route('/get-fear-greed')
def get_fear_greed():
    """Manually fetch Fear & Greed Index data and send in a combined message with app rankings"""
    global last_fear_greed_data, last_fear_greed_time, last_scrape_data, last_scrape_time
    
    if not scheduler:
        return jsonify({"status": "error", "message": "Scheduler not initialized"}), 500
    
    try:
        # Get app rankings data (either existing or new)
        if last_scrape_data:
            # Use existing rankings data
            rankings_data = last_scrape_data
        else:
            # Or fetch new rankings data
            rankings_data = scheduler.scraper.scrape_category_rankings()
            if rankings_data:
                last_scrape_data = rankings_data
                last_scrape_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Get Fear & Greed Index data
        fear_greed_data = scheduler.get_current_fear_greed_index()
        
        if fear_greed_data:
            # Store the data for display
            last_fear_greed_data = fear_greed_data
            last_fear_greed_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
            # Format and send a combined message
            if rankings_data:
                # First add ranking data
                combined_message = scheduler.scraper.format_rankings_message(rankings_data)
                
                # Add separator between messages
                combined_message += "\n\n" + "\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-" + "\n\n"
            else:
                combined_message = ""
                
            # Add Fear & Greed Index data
            combined_message += scheduler.fear_greed_tracker.format_fear_greed_message(fear_greed_data)
            
            # –î–æ–±–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ Altcoin Season Index
            if scheduler.altcoin_season_index:
                # –ü–æ–ª—É—á–∞–µ–º —Å–≤–µ–∂–∏–µ –¥–∞–Ω–Ω—ã–µ Altcoin Season Index
                altseason_data = scheduler.altcoin_season_index.get_altseason_index()
                if altseason_data:
                    altseason_message = scheduler.altcoin_season_index.format_altseason_message(altseason_data)
                    if altseason_message:
                        combined_message += "\n\n" + altseason_message
                        logger.info(f"Added Altcoin Season Index data to combined message: {altseason_data['signal']}")
            
            # Send the message
            sent = scheduler.telegram_bot.send_message(combined_message)
            
            if sent:
                flash("Data successfully fetched and sent to Telegram!", "success")
            else:
                flash("Data fetched but failed to send to Telegram.", "warning")
                
            return redirect(url_for('index'))
        else:
            return jsonify({"status": "error", "message": "Failed to retrieve Fear & Greed Index data"}), 500
    except Exception as e:
        logger.error(f"Error fetching data: {str(e)}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/get-altseason-index')
def get_altseason_index():
    """Manually fetch Altcoin Season Index data and send it as a message"""
    global last_scrape_data, last_scrape_time, last_altseason_data, last_altseason_time
    
    if not scheduler:
        return jsonify({"status": "error", "message": "Scheduler not initialized"}), 500
    
    try:
        # –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ Altcoin Season Index
        logger.info("–ó–∞–ø—Ä–æ—Å –¥–∞–Ω–Ω—ã—Ö Altcoin Season Index...")
        altseason_data = scheduler.altcoin_season_index.get_altseason_index()
        altseason_message = scheduler.altcoin_season_index.format_altseason_message(altseason_data)
        
        if altseason_data:
            logger.info(f"–ü–æ–ª—É—á–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ Altcoin Season Index: {altseason_data['signal']} - {altseason_data['status']}")
        else:
            logger.warning("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ Altcoin Season Index")
        
        if altseason_data:
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
            last_altseason_data = altseason_data
            last_altseason_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
            # –í —Ä—É—á–Ω–æ–º —Ä–µ–∂–∏–º–µ –æ–±—ä–µ–¥–∏–Ω—è–µ–º —Å –¥–∞–Ω–Ω—ã–º–∏ –æ —Ä–µ–π—Ç–∏–Ω–≥–µ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–æ–ª–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
            # –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ –¥–∞–Ω–Ω—ã–µ –æ —Ä–µ–π—Ç–∏–Ω–≥–µ
            rankings_data = last_scrape_data if last_scrape_data else scheduler.scraper.scrape_category_rankings()
            
            # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ Fear & Greed Index
            fear_greed_data = scheduler.fear_greed_tracker.get_fear_greed_index()
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–ª–Ω–æ–µ –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å–æ –≤—Å–µ–º–∏ –¥–∞–Ω–Ω—ã–º–∏
            sent = scheduler.run_now(force_send=True)
            
            if sent:
                flash(f"Complete data with Altcoin Season Index ({altseason_data['signal']}) successfully sent to Telegram!", "success")
            else:
                flash("Data fetched but failed to send to Telegram.", "warning")
                
            return redirect(url_for('index'))
        else:
            return jsonify({"status": "error", "message": "Failed to retrieve Altcoin Season Index data"}), 500
    except Exception as e:
        logger.error(f"Error fetching Altcoin Season Index data: {str(e)}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/health')
def health():
    """Health check endpoint"""
    return jsonify({"status": "ok"})

@app.route('/test-message')
def test_message():
    """Manually send a test message with cached data to the test channel"""
    global last_fear_greed_data, last_scrape_data, last_altseason_data
    
    if not scheduler:
        return jsonify({"status": "error", "message": "Scheduler not initialized"}), 500
    
    try:
        # Get fresh app rankings data from JSON file
        rankings_data = scheduler.scraper.scrape_category_rankings()
        
        # Get fresh Fear & Greed Index data
        fear_greed_data = scheduler.get_current_fear_greed_index()
        
        # Get fresh Market Breadth data (–ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –≤—Å–µ—Ö –º–æ–Ω–µ—Ç)
        market_breadth_data = None
        if scheduler.market_breadth:
            market_breadth_data = scheduler.market_breadth.get_market_breadth_data(fast_mode=False)
        
        # Format individual messages using proper formatting
        rankings_message = scheduler.scraper.format_rankings_message(rankings_data)
        fear_greed_message = scheduler.fear_greed_tracker.format_fear_greed_message(fear_greed_data)
        
        # Build combined message (—Ä–µ–π—Ç–∏–Ω–≥, Fear & Greed, –∏ Market Breadth)
        combined_message = rankings_message
        combined_message += "\n\n" + fear_greed_message
        
        # Add Market Breadth with chart link (same logic as in scheduler)
        if market_breadth_data:
            try:
                png_data = create_quick_chart()
                if png_data:
                    from image_uploader import image_uploader
                    external_url = image_uploader.upload_chart(png_data)
                    if external_url:
                        # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å–æ —Å—Å—ã–ª–∫–æ–π –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–π –≤ —Å—Ç–∞—Ç—É—Å
                        market_breadth_message = f"Market by 200MA: {market_breadth_data['signal']} [{market_breadth_data['condition']}]({external_url}): {market_breadth_data['current_value']:.1f}%"
                        combined_message += f"\n\n{market_breadth_message}"
                    else:
                        # Fallback –±–µ–∑ —Å—Å—ã–ª–∫–∏ - –∏—Å–ø–æ–ª—å–∑—É–µ–º —É–ø—Ä–æ—â–µ–Ω–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç
                        market_breadth_message = f"Market by 200MA: {market_breadth_data['signal']} {market_breadth_data['condition']}: {market_breadth_data['current_value']:.1f}%"
                        combined_message += f"\n\n{market_breadth_message}"
                else:
                    # Fallback –±–µ–∑ —Å—Å—ã–ª–∫–∏ - –∏—Å–ø–æ–ª—å–∑—É–µ–º —É–ø—Ä–æ—â–µ–Ω–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç
                    market_breadth_message = f"Market by 200MA: {market_breadth_data['signal']} {market_breadth_data['condition']}: {market_breadth_data['current_value']:.1f}%"
                    combined_message += f"\n\n{market_breadth_message}"
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –≥—Ä–∞—Ñ–∏–∫–∞ –¥–ª—è test-message: {str(e)}")
                # Fallback –±–µ–∑ —Å—Å—ã–ª–∫–∏
                market_breadth_message = scheduler.market_breadth.format_breadth_message(market_breadth_data)
                if market_breadth_message:
                    combined_message += f"\n\n{market_breadth_message}"
        
        # Send the message
        sent = scheduler.telegram_bot.send_message(combined_message)
        
        if sent:
            return jsonify({
                "status": "success", 
                "message": "Test message sent to Telegram channel",
                "content": combined_message
            })
        else:
            return jsonify({"status": "error", "message": "Failed to send message to Telegram"}), 500
    except Exception as e:
        logger.error(f"Error sending test message: {str(e)}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/api/test_market_breadth')
def test_market_breadth():
    """Test Market Breadth data loading and formatting with fast mode"""
    try:
        if not scheduler or not scheduler.market_breadth:
            return jsonify({"status": "error", "message": "Market breadth not initialized"}), 500
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–ª–Ω—ã–π —Ä–µ–∂–∏–º —Å 50 –º–æ–Ω–µ—Ç–∞–º–∏ –∫–∞–∫ —Ç—Ä–µ–±—É–µ—Ç—Å—è
        logger.info("Starting Market Breadth data loading with full mode (50 coins)...")
        market_breadth_data = scheduler.market_breadth.get_market_breadth_data(fast_mode=False)
        
        if market_breadth_data:
            message = scheduler.market_breadth.format_breadth_message(market_breadth_data)
            return jsonify({
                "status": "success",
                "message": message,
                "data": market_breadth_data
            })
        else:
            return jsonify({"status": "error", "message": "Failed to load market breadth data"}), 500
            
    except Exception as e:
        logger.error(f"Error testing market breadth: {str(e)}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/api/test_format')
def test_format():
    """Test the message formatting with sample data"""
    from scraper import SensorTowerScraper
    from fear_greed_index import FearGreedIndexTracker
    from altcoin_season_index import AltcoinSeasonIndex
    
    try:
        # Create instances for formatting even if scheduler is not running
        scraper = scheduler.scraper if scheduler else SensorTowerScraper()
        fear_greed_tracker = scheduler.fear_greed_tracker if scheduler else FearGreedIndexTracker()
        altcoin_season_index = scheduler.altcoin_season_index if scheduler else AltcoinSeasonIndex()
        
        # Sample app ranking data
        rankings_data = {
            "app_name": "Coinbase",
            "app_id": "886427730",
            "date": datetime.now().strftime("%Y-%m-%d"),
            "categories": [
                {"category": "Finance", "rank": "329", "previous_rank": "332"}
            ],
            "trend": {"direction": "up", "previous": 332}
        }
        
        # Sample fear and greed data
        fear_greed_data = {
            "value": 72,
            "classification": "Greed",
            "date": datetime.now().strftime("%Y-%m-%d")
        }
        
        # Sample Altcoin Season Index data
        altseason_data = {
            "index": 0.65,
            "status": "Moderate Altseason",
            "signal": "üü°",
            "description": "Many altcoins outperform Bitcoin",
            "btc_performance": 8.5,
            "timestamp": int(time.time()),
            "date": datetime.now().strftime('%Y-%m-%d')
        }
        
        # Format individual messages
        rankings_message = scraper.format_rankings_message(rankings_data)
        fear_greed_message = fear_greed_tracker.format_fear_greed_message(fear_greed_data)
        altseason_message = altcoin_season_index.format_altseason_message(altseason_data)
        
        # Format combined message
        combined_message = rankings_message
        combined_message += "\n\n" + fear_greed_message
        
        # –î–æ–±–∞–≤–ª—è–µ–º Altcoin Season Index —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –¥–∞–Ω–Ω—ã–µ –¥–æ—Å—Ç—É–ø–Ω—ã
        if altseason_message:
            combined_message += "\n\n" + altseason_message
        
        # If this is a web request (not API)
        if request.headers.get('Accept', '').find('application/json') == -1:
            return render_template('format_test.html',
                                   rankings_message=rankings_message,
                                   fear_greed_message=fear_greed_message,
                                   altseason_message=altseason_message,
                                   combined_message=combined_message)
        
        # Return JSON for API requests
        return jsonify({
            "status": "success",
            "rankings_message": rankings_message,
            "fear_greed_message": fear_greed_message,
            "altseason_message": altseason_message,
            "combined_message": combined_message
        })
    except Exception as e:
        logger.error(f"Error testing message format: {str(e)}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/set_manual_rank', methods=['POST'])
def set_manual_rank():
    """Set manual rank for Coinbase app"""
    try:
        rank = request.form.get('rank')
        if not rank or not rank.isdigit():
            return jsonify({"status": "error", "message": "Invalid rank value"}), 400
        
        # Save rank to file
        with open('manual_rank.txt', 'w') as f:
            f.write(rank)
        
        logger.info(f"Manual rank set to: {rank}")
        return jsonify({"status": "success", "message": f"Manual rank set to {rank}"})
    except Exception as e:
        logger.error(f"Error setting manual rank: {str(e)}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/test-chart')
def test_chart():
    """Test sending chart link to Telegram"""
    try:
        if not scheduler or not scheduler.telegram_bot:
            flash("‚ùå Telegram bot not available", "danger")
            return redirect(url_for('index'))
        
        # –°–æ–∑–¥–∞–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ –≥—Ä–∞—Ñ–∏–∫  
        chart_url = f"https://{request.host}/chart-view"
        
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –≥—Ä–∞—Ñ–∏–∫ –Ω–∞ –≤–Ω–µ—à–Ω–∏–π —Å–µ—Ä–≤–∏—Å (Imgur/Telegraph)
        try:
            from image_uploader import image_uploader
            
            # –°–æ–∑–¥–∞–µ–º PNG –≥—Ä–∞—Ñ–∏–∫ (–±—ã—Å—Ç—Ä—ã–π –∏ —Ä–∞–±–æ—á–∏–π)
            png_data = create_quick_chart()
            if png_data:
                # –ó–∞–≥—Ä—É–∂–∞–µ–º –Ω–∞ –≤–Ω–µ—à–Ω–∏–π —Å–µ—Ä–≤–∏—Å
                external_url = image_uploader.upload_chart(png_data)
                
                if external_url:
                    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ø–æ–¥–ø–∏—Å–∏
                    if scheduler.market_breadth:
                        market_breadth_data = scheduler.market_breadth.get_market_breadth_data()
                        if market_breadth_data:
                            # –ü–µ—Ä–µ–≤–æ–¥–∏–º —É—Å–ª–æ–≤–∏—è –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π
                            condition_map = {
                                "–ü–µ—Ä–µ–∫—É–ø–ª–µ–Ω–Ω–æ—Å—Ç—å": "Overbought",
                                "–ü–µ—Ä–µ–ø—Ä–æ–¥–∞–Ω–Ω–æ—Å—Ç—å": "Oversold", 
                                "–ù–µ–π—Ç—Ä–∞–ª—å–Ω–∞—è –∑–æ–Ω–∞": "Neutral"
                            }
                            english_condition = condition_map.get(market_breadth_data['condition'], market_breadth_data['condition'])
                            message = f"Market by 200MA: {market_breadth_data['signal']} [{english_condition}]({external_url}): {market_breadth_data['current_value']:.1f}%"
                        else:
                            message = f"Market by 200MA: üü° [Neutral]({external_url}): 50.0%"
                    else:
                        message = f"Market by 200MA: üü° [Neutral]({external_url}): 50.0%"
                    
                    if scheduler.telegram_bot.send_message(message):
                        flash("‚úÖ Chart uploaded and link sent to Telegram successfully", "success")
                    else:
                        flash("‚ùå Failed to send chart link to Telegram", "danger")
                else:
                    flash("‚ùå Failed to upload chart to external service", "danger")
            else:
                flash("‚ùå Failed to generate chart", "danger")
                
        except Exception as e:
            flash(f"‚ùå Error: {str(e)}", "danger")
            
        return redirect(url_for('index'))
    except Exception as e:
        flash(f"‚ùå Error: {str(e)}", "danger")
        return redirect(url_for('index'))

@app.route('/chart-view')
def chart_view():
    """Direct PNG chart for Telegram links"""
    try:
        # –°–æ–∑–¥–∞–µ–º PNG –≥—Ä–∞—Ñ–∏–∫ –Ω–∞–ø—Ä—è–º—É—é
        chart_image = create_chart_from_web_endpoint()
        
        if chart_image:
            from flask import Response
            return Response(chart_image, mimetype='image/png')
        else:
            return "‚ùå Failed to generate chart", 500
        
    except Exception as e:
        logger.error(f"Error generating PNG chart: {str(e)}")
        return f"‚ùå Error: {str(e)}", 500

@app.route('/s/<short_code>')
def redirect_short_url(short_code):
    """–ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ—Ç –∫–æ—Ä–æ—Ç–∫–∏–µ —Å—Å—ã–ª–∫–∏ –Ω–∞ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ URL"""
    try:
        from url_shortener import url_shortener
        
        original_url = url_shortener.get_original_url(short_code)
        if original_url:
            # –ï—Å–ª–∏ —ç—Ç–æ –ª–æ–∫–∞–ª—å–Ω—ã–π URL, –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –ø–æ–ª–Ω—ã–π
            if original_url.startswith('/'):
                original_url = f"https://{request.host}{original_url}"
            elif 'localhost' in original_url:
                original_url = original_url.replace('localhost:5000', request.host)
            
            return redirect(original_url)
        else:
            return "Short URL not found", 404
            
    except Exception as e:
        return f"Error: {str(e)}", 500

@app.route('/market-breadth')
def market_breadth():
    """Market Breadth Analysis - –≤–∞—à —Ç–æ—á–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å"""
    try:
        from crypto_analyzer_cryptocompare import CryptoAnalyzer
        import pandas as pd
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ –±–µ–∑ –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è
        analyzer = CryptoAnalyzer(cache=None)
        
        # –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
        breadth_data = {
            'signal': 'üìä',
            'condition': 'Analysis Ready',
            'description': 'Market breadth analyzer is initialized and ready. Click "Start Analysis" to begin.',
            'current_value': 0,
            'timestamp': 'Ready to start',
            'coins_above_ma': 'N/A',
            'total_coins': '50',
            'cache_info': {'cache_size_mb': 0, 'cached_coins_count': 0, 'status': '–ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–∫–ª—é—á–µ–Ω–æ'}
        }
        
        return render_template('market_breadth_plotly.html', breadth_data=breadth_data)
        
    except Exception as e:
        logger.error(f"Error initializing market breadth: {str(e)}")
        return render_template('market_breadth_plotly.html', 
                             breadth_data=None, error=str(e))

@app.route('/api/run-market-analysis', methods=['POST'])
def run_market_analysis():
    """–ó–∞–ø—É—Å–∫ –ø–æ–ª–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ —Ä—ã–Ω–∫–∞"""
    try:
        from crypto_analyzer_cryptocompare import CryptoAnalyzer
        import pandas as pd
        
        # –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∏–∑ –∑–∞–ø—Ä–æ—Å–∞
        data = request.get_json() or {}
        top_n = data.get('top_n', 50)
        ma_period = data.get('ma_period', 200) 
        history_days = data.get('history_days', 1095)  # 3 –≥–æ–¥–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–µ–∑ –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è
        analyzer = CryptoAnalyzer(cache=None)
        
        # –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–æ–ø –º–æ–Ω–µ—Ç (–≤–∞—à –∫–æ–¥)
        top_coins = analyzer.get_top_coins(top_n)
        if not top_coins:
            return jsonify({"status": "error", "message": "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Ç–æ–ø –º–æ–Ω–µ—Ç"})
        
        # –ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö
        historical_data = analyzer.load_historical_data(
            top_coins, 
            ma_period + history_days + 100
        )
        
        if not historical_data:
            return jsonify({"status": "error", "message": "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ"})
        
        # –†–∞—Å—á–µ—Ç –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ (–≤–∞—à —Ç–æ—á–Ω—ã–π –∫–æ–¥)
        indicator_data = analyzer.calculate_market_breadth(
            historical_data, 
            ma_period, 
            history_days
        )
        
        if indicator_data.empty:
            return jsonify({"status": "error", "message": "–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å—Å—á–∏—Ç–∞—Ç—å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä"})
        
        # –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–≤–æ–¥–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ (–≤–∞—à –∫–æ–¥)
        summary = analyzer.get_market_summary(indicator_data)
        current_value = summary.get('current_value', 0)
        
        # –ü–æ–¥—Å—á–µ—Ç –º–æ–Ω–µ—Ç –≤—ã—à–µ MA –∏—Å–ø–æ–ª—å–∑—É—è –¥–∞–Ω–Ω—ã–µ –∏–∑ summary
        coins_above_ma = summary.get('coins_above_ma', 'N/A')
        
        # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ä—ã–Ω–æ—á–Ω–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞ (–≤–∞—à –∫–æ–¥)
        if current_value >= 80:
            signal = "üî¥"
            condition = "–ü–µ—Ä–µ–∫—É–ø–ª–µ–Ω–Ω–æ—Å—Ç—å"
            description = "–ë–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ –º–æ–Ω–µ—Ç –≤—ã—à–µ MA200, –≤–æ–∑–º–æ–∂–Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ü–∏—è"
        elif current_value <= 20:
            signal = "üü¢" 
            condition = "–ü–µ—Ä–µ–ø—Ä–æ–¥–∞–Ω–Ω–æ—Å—Ç—å"
            description = "–ë–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ –º–æ–Ω–µ—Ç –Ω–∏–∂–µ MA200, –≤–æ–∑–º–æ–∂–µ–Ω –æ—Ç—Å–∫–æ–∫"
        else:
            signal = "üü°"
            condition = "–ù–µ–π—Ç—Ä–∞–ª—å–Ω–∞—è –∑–æ–Ω–∞"
            description = "–†—ã–Ω–æ–∫ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ —Ä–∞–≤–Ω–æ–≤–µ—Å–∏—è"
        
        # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–∞
        last_30_rows = indicator_data.tail(30)
        chart_data = {
            'labels': [str(idx)[:10] for idx in last_30_rows.index],
            'values': last_30_rows['percentage'].tolist()
        }
        
        # –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ –ø–æ—Å–ª–µ–¥–Ω–µ–π –¥–∞—Ç—ã
        try:
            last_date = str(indicator_data.index[-1])
            if ' ' in last_date:
                timestamp = last_date.split(' ')[0]
            else:
                timestamp = last_date[:10]
        except:
            timestamp = 'Latest'
        
        result = {
            'status': 'success',
            'data': {
                'signal': signal,
                'condition': condition,
                'description': description,
                'current_value': current_value,
                'timestamp': timestamp,
                'coins_above_ma': coins_above_ma,
                'total_coins': len(top_coins),
                'avg_value': summary.get('avg_value', 0),
                'max_value': summary.get('max_value', 0),
                'min_value': summary.get('min_value', 0),
                'chart_data': chart_data
            }
        }
        
        return jsonify(result)
        
    except Exception as e:
        logger.error(f"Error in market analysis: {str(e)}")
        return jsonify({"status": "error", "message": str(e)})

@app.route('/api/run-market-analysis-plotly', methods=['POST'])
def run_market_analysis_plotly():
    """–ó–∞–ø—É—Å–∫ –ø–æ–ª–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ —Ä—ã–Ω–∫–∞ —Å Plotly –≥—Ä–∞—Ñ–∏–∫–∞–º–∏ (–≤–∞—à —Ç–æ—á–Ω—ã–π –∫–æ–¥)"""
    try:
        from crypto_analyzer_cryptocompare import CryptoAnalyzer
        import pandas as pd
        from datetime import datetime, timedelta
        
        # –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∏–∑ –∑–∞–ø—Ä–æ—Å–∞
        data = request.get_json() or {}
        top_n = data.get('top_n', 50)
        ma_period = data.get('ma_period', 200) 
        history_days = data.get('history_days', 1095)  # 3 –≥–æ–¥–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–µ–∑ –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è
        analyzer = CryptoAnalyzer(cache=None)
        
        # –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–æ–ø –º–æ–Ω–µ—Ç (–≤–∞—à –∫–æ–¥)
        top_coins = analyzer.get_top_coins(top_n)
        if not top_coins:
            return jsonify({"status": "error", "message": "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Ç–æ–ø –º–æ–Ω–µ—Ç"})
        
        # –ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö
        historical_data = analyzer.load_historical_data(
            top_coins, 
            ma_period + history_days + 100
        )
        
        if not historical_data:
            return jsonify({"status": "error", "message": "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ"})
        
        # –†–∞—Å—á–µ—Ç –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ (–≤–∞—à —Ç–æ—á–Ω—ã–π –∫–æ–¥)
        indicator_data = analyzer.calculate_market_breadth(
            historical_data, 
            ma_period, 
            history_days
        )
        
        if indicator_data.empty:
            return jsonify({"status": "error", "message": "–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å—Å—á–∏—Ç–∞—Ç—å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä"})
        
        # –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–≤–æ–¥–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ (–≤–∞—à –∫–æ–¥)
        summary = analyzer.get_market_summary(indicator_data)
        current_value = summary.get('current_value', 0)
        
        # –ü–æ–¥—Å—á–µ—Ç –º–æ–Ω–µ—Ç –≤—ã—à–µ MA –∏—Å–ø–æ–ª—å–∑—É—è –¥–∞–Ω–Ω—ã–µ –∏–∑ summary
        coins_above_ma = summary.get('coins_above_ma', 'N/A')
        
        # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ä—ã–Ω–æ—á–Ω–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞ (–≤–∞—à –∫–æ–¥)
        if current_value >= 80:
            signal = "üî¥"
            condition = "–ü–µ—Ä–µ–∫—É–ø–ª–µ–Ω–Ω–æ—Å—Ç—å"
            description = "–ë–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ –º–æ–Ω–µ—Ç –≤—ã—à–µ MA200, –≤–æ–∑–º–æ–∂–Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ü–∏—è"
        elif current_value <= 20:
            signal = "üü¢" 
            condition = "–ü–µ—Ä–µ–ø—Ä–æ–¥–∞–Ω–Ω–æ—Å—Ç—å"
            description = "–ë–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ –º–æ–Ω–µ—Ç –Ω–∏–∂–µ MA200, –≤–æ–∑–º–æ–∂–µ–Ω –æ—Ç—Å–∫–æ–∫"
        else:
            signal = "üü°"
            condition = "–ù–µ–π—Ç—Ä–∞–ª—å–Ω–∞—è –∑–æ–Ω–∞"
            description = "–†—ã–Ω–æ–∫ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ —Ä–∞–≤–Ω–æ–≤–µ—Å–∏—è"
        
        # –°–æ–∑–¥–∞–Ω–∏–µ Plotly –¥–∞–Ω–Ω—ã—Ö (–≤–∞—à —Ç–æ—á–Ω—ã–π –∫–æ–¥)
        plotly_data = []
        annotations = []
        shapes = []
        
        # –ì—Ä–∞—Ñ–∏–∫ Bitcoin —Å–≤–µ—Ä—Ö—É
        if 'BTC' in historical_data:
            btc_data = historical_data['BTC'].copy()
            btc_data['date'] = pd.to_datetime(btc_data['date'])
            
            # –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ —Ç–æ–º—É –∂–µ –ø–µ—Ä–∏–æ–¥—É
            end_date = datetime.now().date()
            start_date = end_date - timedelta(days=history_days)
            btc_data = btc_data[(btc_data['date'].dt.date >= start_date) & (btc_data['date'].dt.date <= end_date)]
            
            if not btc_data.empty:
                plotly_data.append({
                    'x': btc_data['date'].dt.strftime('%Y-%m-%d').tolist(),
                    'y': btc_data['price'].tolist(),
                    'mode': 'lines',
                    'name': 'Bitcoin',
                    'line': {'color': '#FF6B35', 'width': 3},
                    'hovertemplate': '<b>%{x}</b><br>BTC Price: $%{y:,.0f}<extra></extra>',
                    'yaxis': 'y'
                })
        
        # –ì—Ä–∞—Ñ–∏–∫ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ —Å–Ω–∏–∑—É
        indicator_data_reset = indicator_data.reset_index()
        plotly_data.append({
            'x': indicator_data_reset['date'].dt.strftime('%Y-%m-%d').tolist() if 'date' in indicator_data_reset.columns else [str(d)[:10] for d in indicator_data_reset.index],
            'y': indicator_data_reset['percentage'].tolist(),
            'mode': 'lines',
            'name': '% Of Cryptocurrencies Above 200-Day Moving Average',
            'line': {'color': '#2563EB', 'width': 3},
            'hovertemplate': '<b>%{x}</b><br>Above MA: %{y:.1f}%<extra></extra>',
            'yaxis': 'y2'
        })
        
        # –õ–∏–Ω–∏–∏ —É—Ä–æ–≤–Ω–µ–π –¥–ª—è –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞
        shapes.extend([
            # –õ–∏–Ω–∏—è 80% - –ø–µ—Ä–µ–∫—É–ø–ª–µ–Ω–Ω–æ—Å—Ç—å  
            {
                'type': 'line',
                'x0': 0, 'x1': 1,
                'y0': 80, 'y1': 80,
                'xref': 'paper', 'yref': 'y2',
                'line': {'color': '#EF4444', 'width': 1.5, 'dash': 'dash'}
            },
            # –õ–∏–Ω–∏—è 20% - –ø–µ—Ä–µ–ø—Ä–æ–¥–∞–Ω–Ω–æ—Å—Ç—å
            {
                'type': 'line',
                'x0': 0, 'x1': 1,
                'y0': 20, 'y1': 20,
                'xref': 'paper', 'yref': 'y2',
                'line': {'color': '#10B981', 'width': 1.5, 'dash': 'dash'}
            },
            # –õ–∏–Ω–∏—è 50% - –Ω–µ–π—Ç—Ä–∞–ª—å–Ω–∞—è –∑–æ–Ω–∞
            {
                'type': 'line',
                'x0': 0, 'x1': 1,
                'y0': 50, 'y1': 50,
                'xref': 'paper', 'yref': 'y2',
                'line': {'color': '#9CA3AF', 'width': 1, 'dash': 'dot'}
            },
            # –ó–æ–Ω–∞ –ø–µ—Ä–µ–∫—É–ø–ª–µ–Ω–Ω–æ—Å—Ç–∏ (–∫—Ä–∞—Å–Ω–∞—è)
            {
                'type': 'rect',
                'x0': 0, 'x1': 1,
                'y0': 80, 'y1': 100,
                'xref': 'paper', 'yref': 'y2',
                'fillcolor': '#FEF2F2', 'opacity': 0.7,
                'layer': 'below', 'line': {'width': 0}
            },
            # –ó–æ–Ω–∞ –ø–µ—Ä–µ–ø—Ä–æ–¥–∞–Ω–Ω–æ—Å—Ç–∏ (–∑–µ–ª–µ–Ω–∞—è) 
            {
                'type': 'rect',
                'x0': 0, 'x1': 1,
                'y0': 0, 'y1': 20,
                'xref': 'paper', 'yref': 'y2',
                'fillcolor': '#F0FDF4', 'opacity': 0.7,
                'layer': 'below', 'line': {'width': 0}
            },
            # –ù–µ–π—Ç—Ä–∞–ª—å–Ω–∞—è –∑–æ–Ω–∞ (—Å–µ—Ä–∞—è)
            {
                'type': 'rect',
                'x0': 0, 'x1': 1,
                'y0': 20, 'y1': 80,
                'xref': 'paper', 'yref': 'y2',
                'fillcolor': '#F9FAFB', 'opacity': 0.5,
                'layer': 'below', 'line': {'width': 0}
            }
        ])
        
        # –ê–Ω–Ω–æ—Ç–∞—Ü–∏–∏
        annotations.extend([
            {
                'x': 1, 'y': 80,
                'xref': 'paper', 'yref': 'y2',
                'text': 'Overbought (80%)',
                'showarrow': False,
                'xanchor': 'right',
                'font': {'size': 10}
            },
            {
                'x': 1, 'y': 20,
                'xref': 'paper', 'yref': 'y2',
                'text': 'Oversold (20%)',
                'showarrow': False,
                'xanchor': 'right',
                'font': {'size': 10}
            },
            {
                'x': 1, 'y': 50,
                'xref': 'paper', 'yref': 'y2',
                'text': 'Neutral Zone (50%)',
                'showarrow': False,
                'xanchor': 'right',
                'font': {'size': 10}
            },

        ])
        
        # –†–∞—Å—á–µ—Ç –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–π (–≤–∞—à –∫–æ–¥)
        correlations = []
        if 'BTC' in historical_data:
            btc_data = historical_data['BTC'].copy()
            btc_data['date'] = pd.to_datetime(btc_data['date'])
            btc_data = btc_data.set_index('date')
            
            for coin_symbol, df in historical_data.items():
                if coin_symbol != 'BTC' and df is not None:
                    try:
                        df = df.copy()
                        df['date'] = pd.to_datetime(df['date'])
                        df = df.set_index('date')
                        
                        # –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ –¥–∞—Ç–∞–º
                        merged = btc_data[['price']].join(df[['price']], rsuffix='_alt', how='inner')
                        
                        if len(merged) > 10:
                            correlation = merged['price'].corr(merged['price_alt'])
                            if pd.notna(correlation):
                                correlations.append({
                                    'coin': coin_symbol,
                                    'correlation': f"{correlation:.3f}"
                                })
                    except Exception as e:
                        logger.debug(f"Error calculating correlation for {coin_symbol}: {e}")
                        continue
        
        # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–π
        correlations.sort(key=lambda x: float(x['correlation']), reverse=True)
        
        # –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ –ø–æ—Å–ª–µ–¥–Ω–µ–π –¥–∞—Ç—ã
        try:
            last_date = str(indicator_data.index[-1])
            if ' ' in last_date:
                timestamp = last_date.split(' ')[0]
            else:
                timestamp = last_date[:10]
        except:
            timestamp = 'Latest'
        
        result = {
            'status': 'success',
            'data': {
                'signal': signal,
                'condition': condition,
                'description': description,
                'current_value': current_value,
                'timestamp': timestamp,
                'coins_above_ma': coins_above_ma,
                'total_coins': len(top_coins),
                'avg_value': summary.get('avg_value', 0),
                'max_value': summary.get('max_value', 0),
                'min_value': summary.get('min_value', 0),
                'plotly_data': {
                    'data': plotly_data,
                    'annotations': annotations,
                    'shapes': shapes
                },
                'correlations': correlations[:20]  # –¢–æ–ø 20 –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–π
            }
        }
        
        return jsonify(result)
        
    except Exception as e:
        logger.error(f"Error in Plotly market analysis: {str(e)}")
        return jsonify({"status": "error", "message": str(e)})

@app.route('/market-breadth-legacy')
def market_breadth_legacy():
    """Display legacy Market Breadth Indicator page"""
    try:
        # –°–æ–∑–¥–∞–µ–º –ø—Ä–æ—Å—Ç—É—é –∑–∞–≥–ª—É—à–∫—É –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
        breadth_data = {
            'signal': '‚è≥',
            'condition': 'Loading...',
            'description': 'Market breadth data is being calculated. Please use refresh button to get latest data.',
            'current_value': 0,
            'timestamp': 'Loading...',
            'coins_above_ma': 'N/A',
            'total_coins': 'N/A'
        }
        
        return render_template('market_breadth.html', breadth_data=breadth_data)
    except Exception as e:
        logger.error(f"Error loading market breadth page: {str(e)}")
        return render_template('market_breadth.html', breadth_data=None, error=str(e))



@app.route('/api/market-breadth-refresh', methods=['POST'])
def market_breadth_refresh():
    """Refresh market breadth data"""
    try:
        # –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ—Ç scheduler, –µ—Å–ª–∏ –æ–Ω –¥–æ—Å—Ç—É–ø–µ–Ω
        if scheduler and scheduler.market_breadth:
            breadth_data = scheduler.market_breadth.get_market_breadth_data()
            if breadth_data:
                return jsonify({
                    "status": "success", 
                    "message": "Market breadth data refreshed successfully",
                    "data": breadth_data
                })
            else:
                return jsonify({"status": "error", "message": "Market breadth data not yet available"}), 500
        else:
            return jsonify({"status": "error", "message": "Market breadth analyzer not initialized"}), 500
            
    except Exception as e:
        logger.error(f"Error refreshing market breadth data: {str(e)}")
        return jsonify({"status": "error", "message": str(e)}), 500

def create_market_chart_screenshot():
    """
    –°–æ–∑–¥–∞–µ—Ç —Å–∫—Ä–∏–Ω—à–æ—Ç –≥—Ä–∞—Ñ–∏–∫–∞ —Ä—ã–Ω–∫–∞ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ Telegram
    
    Returns:
        bytes: PNG –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≥—Ä–∞—Ñ–∏–∫–∞ –∏–ª–∏ None –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏
    """
    try:
        import plotly.graph_objects as go
        from plotly.subplots import make_subplots
        import plotly.io as pio
        from crypto_analyzer_cryptocompare import CryptoAnalyzer
        import pandas as pd
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–µ–∑ –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è
        analyzer = CryptoAnalyzer(cache=None)
        
        # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∞–Ω–∞–ª–∏–∑–∞
        top_n = 50
        ma_period = 200
        history_days = 1095  # 3 –≥–æ–¥–∞ –¥–ª—è Telegram –≥—Ä–∞—Ñ–∏–∫–∞
        
        # –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
        top_coins = analyzer.get_top_coins(top_n)
        if not top_coins:
            logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Ç–æ–ø –º–æ–Ω–µ—Ç –¥–ª—è —Å–∫—Ä–∏–Ω—à–æ—Ç–∞")
            return None
        
        # –ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö
        historical_data = analyzer.load_historical_data(
            top_coins, 
            ma_period + history_days + 100
        )
        
        if not historical_data:
            logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Å–∫—Ä–∏–Ω—à–æ—Ç–∞")
            return None
        
        # –†–∞—Å—á–µ—Ç –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞
        indicator_data = analyzer.calculate_market_breadth(
            historical_data, 
            ma_period, 
            history_days
        )
        
        if indicator_data.empty:
            logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å—Å—á–∏—Ç–∞—Ç—å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –¥–ª—è —Å–∫—Ä–∏–Ω—à–æ—Ç–∞")
            return None
        
        # –°–æ–∑–¥–∞–Ω–∏–µ —É–ø—Ä–æ—â–µ–Ω–Ω–æ–≥–æ –≥—Ä–∞—Ñ–∏–∫–∞ –¥–ª—è Telegram
        fig = make_subplots(
            rows=2, cols=1,
            subplot_titles=('Bitcoin Price (USD)', '% Of Cryptocurrencies Above 200-Day Moving Average'),
            vertical_spacing=0.08,
            row_heights=[0.6, 0.4]
        )
        
        # –ì—Ä–∞—Ñ–∏–∫ Bitcoin (–≤–µ—Ä—Ö–Ω–∏–π)
        if 'BTC' in historical_data:
            btc_data = historical_data['BTC'].copy()
            logger.info(f"BTC data columns: {btc_data.columns.tolist()}")
            logger.info(f"BTC data shape: {btc_data.shape}")
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –Ω—É–∂–Ω—ã—Ö –∫–æ–ª–æ–Ω–æ–∫
            if 'date' not in btc_data.columns:
                btc_data.reset_index(inplace=True)
            
            btc_data['date'] = pd.to_datetime(btc_data['date'])
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–æ–ª–æ–Ω–∫–∏ —Å —Ü–µ–Ω–æ–π
            price_column = 'close'
            if 'close' not in btc_data.columns:
                # –ü–æ–ø—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è
                possible_names = ['Close', 'price', 'Price', 'last', 'Last']
                for name in possible_names:
                    if name in btc_data.columns:
                        price_column = name
                        break
                else:
                    # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–≤—É—é —á–∏—Å–ª–æ–≤—É—é –∫–æ–ª–æ–Ω–∫—É
                    numeric_cols = btc_data.select_dtypes(include=[float, int]).columns
                    if len(numeric_cols) > 0:
                        price_column = numeric_cols[0]
                    else:
                        logger.error(f"–ù–µ –Ω–∞–π–¥–µ–Ω–∞ –∫–æ–ª–æ–Ω–∫–∞ —Å —Ü–µ–Ω–æ–π Bitcoin: {btc_data.columns.tolist()}")
                        return None
            
            # –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ –ø–µ—Ä–∏–æ–¥—É –∞–Ω–∞–ª–∏–∑–∞
            btc_recent = btc_data.tail(history_days)
            
            fig.add_trace(
                go.Scatter(
                    x=btc_recent['date'],
                    y=btc_recent[price_column],
                    name='Bitcoin',
                    line=dict(color='#f7931a', width=2),
                    showlegend=False
                ),
                row=1, col=1
            )
        
        # –ì—Ä–∞—Ñ–∏–∫ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ (–Ω–∏–∂–Ω–∏–π)
        logger.info(f"Indicator data columns: {indicator_data.columns.tolist()}")
        logger.info(f"Indicator data shape: {indicator_data.shape}")
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–æ–ª–æ–Ω–∫–∏ —Å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–º
        breadth_column = 'percentage_above_ma'
        if 'percentage_above_ma' not in indicator_data.columns:
            # –ü–æ–ø—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è
            possible_names = ['market_breadth', 'breadth', 'percentage', 'above_ma']
            for name in possible_names:
                if name in indicator_data.columns:
                    breadth_column = name
                    break
            else:
                # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–≤—É—é —á–∏—Å–ª–æ–≤—É—é –∫–æ–ª–æ–Ω–∫—É
                numeric_cols = indicator_data.select_dtypes(include=[float, int]).columns
                if len(numeric_cols) > 0:
                    breadth_column = numeric_cols[0]
                else:
                    logger.error(f"–ù–µ –Ω–∞–π–¥–µ–Ω–∞ –∫–æ–ª–æ–Ω–∫–∞ —Å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–º: {indicator_data.columns.tolist()}")
                    return None
        
        fig.add_trace(
            go.Scatter(
                x=pd.to_datetime(indicator_data.index),
                y=indicator_data[breadth_column],
                name='Market Breadth',
                line=dict(color='#2563EB', width=2),
                showlegend=False
            ),
            row=2, col=1
        )
        
        # –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ –¥–ª—è –∑–æ–Ω
        fig.add_hline(y=80, line_dash="dash", line_color="red", opacity=0.7, row=2, col=1)
        fig.add_hline(y=50, line_dash="dot", line_color="gray", opacity=0.5, row=2, col=1)
        fig.add_hline(y=20, line_dash="dash", line_color="green", opacity=0.7, row=2, col=1)
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –º–∞–∫–µ—Ç–∞
        fig.update_layout(
            title={
                'text': 'Cryptocurrency Market Analysis',
                'x': 0.5,
                'font': {'size': 20, 'color': '#2c3e50'}
            },
            height=600,
            width=800,
            font=dict(family="Arial", size=12),
            plot_bgcolor='white',
            paper_bgcolor='white',
            margin=dict(l=50, r=50, t=80, b=50)
        )
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ—Å–µ–π
        fig.update_xaxes(
            gridcolor='lightgray',
            gridwidth=0.5,
            showgrid=True
        )
        fig.update_yaxes(
            gridcolor='lightgray',
            gridwidth=0.5,
            showgrid=True
        )
        
        # –°–æ–∑–¥–∞–Ω–∏–µ PNG –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å fallback –Ω–∞ matplotlib
        try:
            img_bytes = pio.to_image(
                fig, 
                format='png',
                width=800,
                height=600,
                scale=2  # –í—ã—Å–æ–∫–æ–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ
            )
            logger.info("–ì—Ä–∞—Ñ–∏–∫ –¥–ª—è Telegram —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω —á–µ—Ä–µ–∑ Kaleido")
            return img_bytes
        except Exception as kaleido_error:
            logger.warning(f"Kaleido –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç: {str(kaleido_error)}, –ø—Ä–æ–±—É–µ–º matplotlib")
            
            # Fallback –Ω–∞ matplotlib
            import matplotlib.pyplot as plt
            import matplotlib.dates as mdates
            from io import BytesIO
            
            # –°–æ–∑–¥–∞–µ–º –≥—Ä–∞—Ñ–∏–∫ —Å matplotlib
            fig_mpl, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))
            
            # –ì—Ä–∞—Ñ–∏–∫ Bitcoin (–≤–µ—Ä—Ö–Ω–∏–π)
            if 'BTC' in historical_data:
                btc_data = historical_data['BTC'].copy()
                if 'date' not in btc_data.columns:
                    btc_data.reset_index(inplace=True)
                btc_data['date'] = pd.to_datetime(btc_data['date'])
                
                # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–æ–ª–æ–Ω–∫–∏ —Å —Ü–µ–Ω–æ–π
                price_column = 'price' if 'price' in btc_data.columns else 'close'
                if price_column not in btc_data.columns:
                    numeric_cols = btc_data.select_dtypes(include=[float, int]).columns
                    if len(numeric_cols) > 0:
                        price_column = numeric_cols[0]
                
                btc_recent = btc_data.tail(history_days)
                ax1.plot(btc_recent['date'], btc_recent[price_column], 
                        color='#f7931a', linewidth=2, label='Bitcoin')
                ax1.set_title('Bitcoin Price (USD)', fontsize=14, fontweight='bold')
                ax1.grid(True, alpha=0.3)
                ax1.set_ylabel('Price (USD)')
                
            # –ì—Ä–∞—Ñ–∏–∫ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ (–Ω–∏–∂–Ω–∏–π)
            breadth_column = 'percentage'
            if breadth_column in indicator_data.columns:
                ax2.plot(pd.to_datetime(indicator_data.index), indicator_data[breadth_column],
                        color='#2563EB', linewidth=2, label='Market Breadth')
                
                # –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏
                ax2.axhline(y=80, color='red', linestyle='--', alpha=0.7, label='Overbought (80%)')
                ax2.axhline(y=50, color='gray', linestyle=':', alpha=0.5, label='Neutral (50%)')
                ax2.axhline(y=20, color='green', linestyle='--', alpha=0.7, label='Oversold (20%)')
                
                ax2.set_title('% Of Cryptocurrencies Above 200-Day Moving Average', fontsize=14, fontweight='bold', pad=20)
                ax2.set_ylabel('Percentage (%)')
                ax2.grid(True, alpha=0.3)
                ax2.set_ylim(0, 100)
                
                # –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞—Ç
                ax2.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))
                ax2.xaxis.set_major_locator(mdates.MonthLocator(interval=3))
                
            plt.tight_layout()
            
            # –ü—Ä–æ—Å—Ç–æ–π –∑–∞–≥–æ–ª–æ–≤–æ–∫ –±–µ–∑ –æ–ø–∏—Å–∞–Ω–∏—è
            plt.suptitle('% Of Cryptocurrencies Above 200-Day Moving Average', 
                        fontsize=14, fontweight='bold', y=0.95)
            
            # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ BytesIO
            img_buffer = BytesIO()
            plt.savefig(img_buffer, format='png', dpi=150, bbox_inches='tight')
            img_buffer.seek(0)
            img_bytes = img_buffer.getvalue()
            plt.close(fig_mpl)
            
            logger.info("–ì—Ä–∞—Ñ–∏–∫ –¥–ª—è Telegram —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω —á–µ—Ä–µ–∑ matplotlib")
            return img_bytes
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å–∫—Ä–∏–Ω—à–æ—Ç–∞ –≥—Ä–∞—Ñ–∏–∫–∞: {str(e)}")
        return None

def create_web_ui_chart_screenshot():
    """
    –°–æ–∑–¥–∞–µ—Ç –≥—Ä–∞—Ñ–∏–∫ —Å —Ç–æ—á–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
    """
    try:
        from crypto_analyzer_cryptocompare import CryptoAnalyzer
        import pandas as pd
        import plotly.graph_objects as go
        import plotly.io as pio
        from datetime import datetime, timedelta
        import numpy as np
        
        logger.info("–°–æ–∑–¥–∞–Ω–∏–µ –≥—Ä–∞—Ñ–∏–∫–∞ —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞...")
        
        # –¢–û–ß–ù–û –¢–ï –ñ–ï –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —á—Ç–æ –≤ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ
        top_n = 50
        ma_period = 200
        history_days = 1095  # 3 –≥–æ–¥–∞
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–µ–∑ –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è
        analyzer = CryptoAnalyzer(cache=None)
        
        # –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
        top_coins = analyzer.get_top_coins(top_n)
        if not top_coins:
            logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ç–æ–ø –º–æ–Ω–µ—Ç—ã")
            return None
            
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞
        total_days_needed = ma_period + history_days + 100
        historical_data = analyzer.load_historical_data(top_coins, total_days_needed)
        
        if not historical_data:
            logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ")
            return None
        
        # –†–∞—Å—á–µ—Ç –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞
        indicator_data = analyzer.calculate_market_breadth(
            historical_data, 
            ma_period, 
            history_days
        )
        
        if indicator_data.empty:
            logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å—Å—á–∏—Ç–∞—Ç—å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä")
            return None
        
        logger.info(f"–†–∞—Å—Å—á–∏—Ç–∞–Ω –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –¥–ª—è {len(indicator_data)} –¥–Ω–µ–π")
        
        # –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö Bitcoin –¥–ª—è –≤–µ—Ä—Ö–Ω–µ–≥–æ –≥—Ä–∞—Ñ–∏–∫–∞
        btc_data = None
        if 'BTC' in historical_data:
            btc_data = historical_data['BTC'].copy()
            btc_data['date'] = pd.to_datetime(btc_data['date'])
            
            # –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ —Ç–æ–º—É –∂–µ –ø–µ—Ä–∏–æ–¥—É
            end_date = datetime.now().date()
            start_date = end_date - timedelta(days=history_days)
            btc_data = btc_data[
                (btc_data['date'].dt.date >= start_date) & 
                (btc_data['date'].dt.date <= end_date)
            ].sort_values('date')
        
        # –°–æ–∑–¥–∞–Ω–∏–µ –¢–û–ß–ù–û –¢–ê–ö–û–ì–û –ñ–ï –≥—Ä–∞—Ñ–∏–∫–∞ –∫–∞–∫ –≤ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ
        fig = go.Figure()
        
        # Bitcoin –≥—Ä–∞—Ñ–∏–∫ (–≤–µ—Ä—Ö–Ω–∏–π)
        if btc_data is not None and not btc_data.empty:
            fig.add_trace(go.Scatter(
                x=btc_data['date'],
                y=btc_data['price'],
                mode='lines',
                name='Bitcoin',
                line=dict(color='#FF6B35', width=2),
                yaxis='y1'
            ))
        
        # Market breadth –≥—Ä–∞—Ñ–∏–∫ (–Ω–∏–∂–Ω–∏–π)
        indicator_filtered = indicator_data.tail(history_days)
        dates = pd.to_datetime(indicator_filtered.index)
        
        fig.add_trace(go.Scatter(
            x=dates,
            y=indicator_filtered['percentage'],
            mode='lines',
            name='% Of Cryptocurrencies Above 200-Day Moving Average',
            line=dict(color='#2563EB', width=2),
            yaxis='y2'
        ))
        
        # Layout —Ç–æ—á–Ω–æ –∫–∞–∫ –≤ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ
        fig.update_layout(
            title=dict(
                text='',
                x=0.5,
                font=dict(size=16, color='#2D3748')
            ),
            showlegend=True,
            plot_bgcolor='white',
            paper_bgcolor='white',
            margin=dict(l=60, r=60, t=80, b=120),
            height=700,
            width=1200,
            font=dict(family="Arial, sans-serif", size=12, color='#4A5568'),
            
            # –î–≤–æ–π–Ω–∞—è –æ—Å—å Y
            yaxis=dict(
                title='Bitcoin Price (USD)',
                side='left',
                titlefont=dict(color='#FF6B35'),
                tickfont=dict(color='#FF6B35'),
                domain=[0.55, 1],
                showgrid=True,
                gridcolor='#E2E8F0',
                gridwidth=1
            ),
            yaxis2=dict(
                title='Percentage (%)',
                side='left',
                titlefont=dict(color='#2563EB'),
                tickfont=dict(color='#2563EB'),
                domain=[0, 0.45],
                range=[0, 100],
                showgrid=True,
                gridcolor='#E2E8F0',
                gridwidth=1
            ),
            xaxis=dict(
                title='Date',
                showgrid=True,
                gridcolor='#E2E8F0',
                gridwidth=1,
                domain=[0, 1]
            ),
            legend=dict(
                x=0.02,
                y=0.98,
                bgcolor='rgba(255,255,255,0.8)',
                bordercolor='#CBD5E0',
                borderwidth=1
            )
        )
        
        # –î–æ–±–∞–≤–ª—è–µ–º –∑–æ–Ω—ã –Ω–∞ –Ω–∏–∂–Ω–∏–π –≥—Ä–∞—Ñ–∏–∫
        fig.add_hline(y=80, line=dict(color='#FCA5A5', width=1, dash='dash'), yref='y2')
        fig.add_hline(y=50, line=dict(color='#9CA3AF', width=1, dash='dash'), yref='y2')
        fig.add_hline(y=20, line=dict(color='#86EFAC', width=1, dash='dash'), yref='y2')
        
        # –î–æ–±–∞–≤–ª—è–µ–º —Ü–≤–µ—Ç–Ω—ã–µ –∑–æ–Ω—ã
        fig.add_hrect(y0=80, y1=100, fillcolor='#FEF2F2', opacity=0.3, yref='y2')
        fig.add_hrect(y0=20, y1=80, fillcolor='#F9FAFB', opacity=0.2, yref='y2')
        fig.add_hrect(y0=0, y1=20, fillcolor='#F0FDF4', opacity=0.3, yref='y2')
        
        # –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ PNG
        try:
            img_bytes = pio.to_image(
                fig, 
                format='png',
                width=1200,
                height=700,
                scale=2
            )
            logger.info("–ì—Ä–∞—Ñ–∏–∫ —Å–æ–∑–¥–∞–Ω —á–µ—Ä–µ–∑ Plotly —É—Å–ø–µ—à–Ω–æ")
            return img_bytes
        except Exception as plotly_error:
            logger.error(f"–û—à–∏–±–∫–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ Plotly –≤ PNG: {plotly_error}")
            # Fallback –Ω–∞ matplotlib
            return create_matplotlib_fallback_chart(indicator_data, btc_data, history_days)
            
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –≥—Ä–∞—Ñ–∏–∫–∞: {str(e)}")
        import traceback
        logger.error(f"–ü–æ–ª–Ω–∞—è –æ—à–∏–±–∫–∞: {traceback.format_exc()}")
        return None

def create_matplotlib_fallback_chart(indicator_data, btc_data, history_days):
    """
    Fallback —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –≥—Ä–∞—Ñ–∏–∫–∞ —á–µ—Ä–µ–∑ matplotlib
    """
    try:
        import matplotlib.pyplot as plt
        import matplotlib.dates as mdates
        from io import BytesIO
        
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(14, 10))
        fig.patch.set_facecolor('white')
        
        # Bitcoin –≥—Ä–∞—Ñ–∏–∫
        if btc_data is not None and not btc_data.empty:
            ax1.plot(btc_data['date'], btc_data['price'], 
                    color='#FF6B35', linewidth=2, label='Bitcoin')
            ax1.set_title('Bitcoin Price (USD)', fontsize=14, fontweight='bold', color='#2D3748')
            ax1.set_ylabel('Bitcoin Price (USD)', fontsize=12, color='#4A5568')
            ax1.grid(True, alpha=0.3, color='#E2E8F0')
        
        # Market breadth –≥—Ä–∞—Ñ–∏–∫
        indicator_filtered = indicator_data.tail(history_days)
        dates = pd.to_datetime(indicator_filtered.index)
        
        ax2.plot(dates, indicator_filtered['percentage'], 
                color='#2563EB', linewidth=2)
        
        # –ó–æ–Ω—ã
        ax2.axhspan(80, 100, alpha=0.3, color='#FEF2F2')
        ax2.axhspan(0, 20, alpha=0.3, color='#F0FDF4')
        ax2.axhspan(20, 80, alpha=0.2, color='#F9FAFB')
        
        ax2.set_title('% Of Cryptocurrencies Above 200-Day Moving Average', 
                     fontsize=14, fontweight='bold', color='#2D3748', pad=20)
        ax2.set_ylabel('Percentage (%)', fontsize=12, color='#4A5568')
        ax2.set_xlabel('Date', fontsize=12, color='#4A5568')
        ax2.set_ylim(0, 100)
        ax2.grid(True, alpha=0.3, color='#E2E8F0')
        
        plt.tight_layout()
        
        # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
        img_buffer = BytesIO()
        plt.savefig(img_buffer, format='png', dpi=150, bbox_inches='tight', 
                   facecolor='white', edgecolor='none')
        img_buffer.seek(0)
        img_bytes = img_buffer.getvalue()
        plt.close(fig)
        
        logger.info("–ì—Ä–∞—Ñ–∏–∫ —Å–æ–∑–¥–∞–Ω —á–µ—Ä–µ–∑ matplotlib fallback")
        return img_bytes
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è matplotlib fallback: {str(e)}")
        return None

def create_chart_from_web_endpoint():
    """
    –°–æ–∑–¥–∞–µ—Ç –≥—Ä–∞—Ñ–∏–∫ —Ç–æ—á–Ω–æ –∫–∞–∫ –≤ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ —Å 3-–ª–µ—Ç–Ω–∏–º–∏ –¥–∞–Ω–Ω—ã–º–∏
    """
    try:
        logger.info("–°–æ–∑–¥–∞–µ–º –≥—Ä–∞—Ñ–∏–∫ —Ç–æ—á–Ω–æ –∫–∞–∫ –≤ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ...")
        
        # –¢–æ—á–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
        top_n = 50
        ma_period = 200
        history_days = 1095  # 3 –≥–æ–¥–∞ –∫–∞–∫ –≤ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ
        
        # –°–æ–∑–¥–∞–µ–º –≥—Ä–∞—Ñ–∏–∫ —Å —Ç–æ—á–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
        return create_exact_web_interface_chart(top_n, ma_period, history_days)
            
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –≥—Ä–∞—Ñ–∏–∫–∞ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞: {str(e)}")
        return None

def create_exact_web_interface_chart(top_n, ma_period, history_days):
    """
    –°–æ–∑–¥–∞–µ—Ç –≥—Ä–∞—Ñ–∏–∫ —Ç–æ—á–Ω–æ —Ç–∞–∫–æ–π –∂–µ –∫–∞–∫ –≤ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ
    """
    try:
        import plotly.graph_objects as go
        from plotly.subplots import make_subplots
        import pandas as pd
        from datetime import datetime, timedelta
        from crypto_analyzer_cryptocompare import CryptoAnalyzer
        from io import BytesIO
        import matplotlib.pyplot as plt
        import matplotlib.dates as mdates
        
        logger.info(f"–°–æ–∑–¥–∞–µ–º —Ç–æ—á–Ω—É—é –∫–æ–ø–∏—é –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞: {top_n} –º–æ–Ω–µ—Ç, {ma_period}MA, {history_days} –¥–Ω–µ–π")
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–µ–∑ –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è
        analyzer = CryptoAnalyzer(cache=None)
        
        # –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
        top_coins = analyzer.get_top_coins(top_n)
        if not top_coins:
            logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ç–æ–ø –º–æ–Ω–µ—Ç—ã")
            return None
        
        # –ò—Å–∫–ª—é—á–∞–µ–º —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω—ã –∫–∞–∫ –≤ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ
        stablecoins = ['USDT', 'USDC', 'DAI']
        filtered_coins = [coin for coin in top_coins if coin['symbol'] not in stablecoins]
        logger.info(f"–û—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–æ {len(filtered_coins)} –º–æ–Ω–µ—Ç (–∏—Å–∫–ª—é—á–µ–Ω—ã —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω—ã)")
        
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∫–∞–∫ –≤ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ
        total_days_needed = ma_period + history_days + 100
        historical_data = analyzer.load_historical_data(filtered_coins, total_days_needed)
        
        if not historical_data:
            logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ")
            return None
        
        # –†–∞—Å—á–µ—Ç –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ —Ç–æ—á–Ω–æ –∫–∞–∫ –≤ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ
        indicator_data = analyzer.calculate_market_breadth(
            historical_data, 
            ma_period, 
            history_days
        )
        
        if indicator_data.empty:
            logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å—Å—á–∏—Ç–∞—Ç—å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä")
            return None
            
        logger.info(f"–†–∞—Å—Å—á–∏—Ç–∞–Ω –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –¥–ª—è {len(indicator_data)} –¥–Ω–µ–π")
        
        # –°–æ–∑–¥–∞–Ω–∏–µ –¥–≤—É—Ö–ø–∞–Ω–µ–ª—å–Ω–æ–≥–æ –≥—Ä–∞—Ñ–∏–∫–∞ –∫–∞–∫ –≤ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(14, 10))
        fig.patch.set_facecolor('white')
        
        # Bitcoin –≥—Ä–∞—Ñ–∏–∫ (–≤–µ—Ä—Ö–Ω—è—è –ø–∞–Ω–µ–ª—å)
        if 'BTC' in historical_data:
            btc_data = historical_data['BTC'].copy()
            btc_data['date'] = pd.to_datetime(btc_data['date'])
            
            # –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ —Ç–æ—á–Ω–æ–º—É –ø–µ—Ä–∏–æ–¥—É –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
            end_date = datetime.now().date()
            start_date = end_date - timedelta(days=history_days)
            btc_filtered = btc_data[
                (btc_data['date'].dt.date >= start_date) & 
                (btc_data['date'].dt.date <= end_date)
            ].sort_values('date')
            
            if not btc_filtered.empty:
                ax1.plot(btc_filtered['date'], btc_filtered['price'], 
                        color='#FF6B35', linewidth=2.5, label='Bitcoin')
                ax1.set_title('Bitcoin Price (USD)', 
                            fontsize=16, fontweight='bold', pad=20)
                ax1.set_ylabel('Bitcoin Price (USD)', fontsize=13)
                ax1.grid(True, alpha=0.3, linestyle='-', linewidth=0.5)
                ax1.tick_params(axis='both', which='major', labelsize=11)
                
                # –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ü–µ–Ω—ã
                ax1.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))
        
        # Market breadth –≥—Ä–∞—Ñ–∏–∫ (–Ω–∏–∂–Ω—è—è –ø–∞–Ω–µ–ª—å) - —Ç–æ—á–Ω–æ –∫–∞–∫ –≤ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ
        indicator_filtered = indicator_data.tail(history_days)
        dates = pd.to_datetime(indicator_filtered.index)
        
        # –û—Å–Ω–æ–≤–Ω–∞—è –ª–∏–Ω–∏—è –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞
        ax2.plot(dates, indicator_filtered['percentage'], 
                color='#2563EB', linewidth=2.5, label='Market Breadth')
        
        # –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ –∑–æ–Ω—ã —Å –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–º–∏ —Ü–≤–µ—Ç–∞–º–∏
        ax2.axhspan(80, 100, alpha=0.15, color='#FF4757', label='Overbought Zone')
        ax2.axhspan(0, 20, alpha=0.15, color='#2ED573', label='Oversold Zone')
        ax2.axhspan(20, 80, alpha=0.05, color='#57606F', label='Neutral Zone')
        
        # –ü—É–Ω–∫—Ç–∏—Ä–Ω—ã–µ –ª–∏–Ω–∏–∏ –¥–ª—è –≥—Ä–∞–Ω–∏—Ü –∑–æ–Ω
        ax2.axhline(y=80, color='#FF3742', linestyle='--', alpha=0.8, linewidth=2)
        ax2.axhline(y=20, color='#26C059', linestyle='--', alpha=0.8, linewidth=2)
        ax2.axhline(y=50, color='#747D8C', linestyle='-', alpha=0.4, linewidth=1)
        
        # –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ –ø–æ–¥–ø–∏—Å–∏ –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–æ–º (—Å–ª–µ–≤–∞ –æ—Ç –≥—Ä–∞—Ñ–∏–∫–∞)
        ax2.text(0.02, 90, 'OVERBOUGHT', transform=ax2.get_yaxis_transform(), 
                fontsize=11, fontweight='600', color='#FF3742', alpha=0.9,
                bbox=dict(boxstyle='round,pad=0.4', facecolor='white', alpha=0.95, edgecolor='#FF3742', linewidth=1),
                ha='left')
        
        ax2.text(0.02, 10, 'OVERSOLD', transform=ax2.get_yaxis_transform(), 
                fontsize=11, fontweight='600', color='#26C059', alpha=0.9,
                bbox=dict(boxstyle='round,pad=0.4', facecolor='white', alpha=0.95, edgecolor='#26C059', linewidth=1),
                ha='left')
        
        ax2.text(0.02, 50, 'NEUTRAL', transform=ax2.get_yaxis_transform(), 
                fontsize=11, fontweight='600', color='#747D8C', alpha=0.9,
                bbox=dict(boxstyle='round,pad=0.4', facecolor='white', alpha=0.95, edgecolor='#747D8C', linewidth=1),
                ha='left')
        
        ax2.set_title('% Of Cryptocurrencies Above 200-Day Moving Average', 
                     fontsize=16, fontweight='bold', pad=20)
        ax2.set_ylabel('Percentage (%)', fontsize=13)
        ax2.set_xlabel('Date', fontsize=13)
        ax2.set_ylim(0, 100)
        ax2.grid(True, alpha=0.3, linestyle='-', linewidth=0.5)
        ax2.tick_params(axis='both', which='major', labelsize=11)
        
        # –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞—Ç —Ç–æ—á–Ω–æ –∫–∞–∫ –≤ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ
        ax2.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))
        ax2.xaxis.set_major_locator(mdates.MonthLocator(interval=3))
        
        # –î–æ–±–∞–≤–ª—è–µ–º –∞–Ω–Ω–æ—Ç–∞—Ü–∏—é –∫–∞–∫ –≤ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ
        current_value = indicator_filtered['percentage'].iloc[-1]
        ax2.text(0.02, 0.98, 
                f'Current: {current_value:.1f}%\nAnalyzing {len(filtered_coins)} cryptocurrencies\nOver {history_days} days with {ma_period}-day MA',
                transform=ax2.transAxes, fontsize=10, verticalalignment='top',
                bbox=dict(boxstyle='round', facecolor='white', alpha=0.8, edgecolor='gray'))
        

        
        # –§–∏–Ω–∞–ª—å–Ω–æ–µ –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏–µ
        plt.tight_layout()
        
        # –ü—Ä–æ—Å—Ç–æ–π –∑–∞–≥–æ–ª–æ–≤–æ–∫ –±–µ–∑ –æ–ø–∏—Å–∞–Ω–∏—è
        plt.suptitle('% Of Cryptocurrencies Above 200-Day Moving Average', 
                    fontsize=14, fontweight='bold', y=0.95)
        plt.subplots_adjust(top=0.94, hspace=0.3)
        
        # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –≤—ã—Å–æ–∫–æ–º –∫–∞—á–µ—Å—Ç–≤–µ
        img_buffer = BytesIO()
        plt.savefig(img_buffer, format='png', dpi=200, bbox_inches='tight', 
                   facecolor='white', edgecolor='none', 
                   pad_inches=0.2)
        img_buffer.seek(0)
        img_bytes = img_buffer.getvalue()
        plt.close(fig)
        
        logger.info("–ì—Ä–∞—Ñ–∏–∫ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ —Å–æ–∑–¥–∞–Ω —É—Å–ø–µ—à–Ω–æ")
        return img_bytes
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ç–æ—á–Ω–æ–≥–æ –≥—Ä–∞—Ñ–∏–∫–∞ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞: {str(e)}")
        import traceback
        logger.error(f"–ü–æ–ª–Ω–∞—è –æ—à–∏–±–∫–∞: {traceback.format_exc()}")
        return None

def create_quick_chart():
    """
    –°–æ–∑–¥–∞–µ—Ç –≥—Ä–∞—Ñ–∏–∫ —Å —Å–æ–∫—Ä–∞—â–µ–Ω–Ω—ã–º –ø–µ—Ä–∏–æ–¥–æ–º –¥–ª—è –±—ã—Å—Ç—Ä–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏
    """
    try:
        from crypto_analyzer_cryptocompare import CryptoAnalyzer
        import pandas as pd
        import matplotlib.pyplot as plt
        import matplotlib.dates as mdates
        from io import BytesIO
        from datetime import datetime, timedelta
        
        logger.info("–°–æ–∑–¥–∞–µ–º –±—ã—Å—Ç—Ä—ã–π –≥—Ä–∞—Ñ–∏–∫...")
        
        # –ü–æ–ª–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∫–∞–∫ —Ç—Ä–µ–±—É–µ—Ç—Å—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
        top_n = 50  # –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û 50 –ú–û–ù–ï–¢ –∫–∞–∫ —Ç—Ä–µ–±—É–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
        ma_period = 200
        history_days = 1095  # 3 –≥–æ–¥–∞ –¥–∞–Ω–Ω—ã—Ö –∫–∞–∫ –≤ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–µ–∑ –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è
        analyzer = CryptoAnalyzer(cache=None)
        
        # –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
        top_coins = analyzer.get_top_coins(top_n)
        if not top_coins:
            logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ç–æ–ø –º–æ–Ω–µ—Ç—ã")
            return None
            
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –º–µ–Ω—å—à–µ –¥–∞–Ω–Ω—ã—Ö
        total_days_needed = ma_period + history_days + 50
        historical_data = analyzer.load_historical_data(top_coins, total_days_needed)
        
        if not historical_data:
            logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ")
            return None
        
        # –†–∞—Å—á–µ—Ç –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞
        indicator_data = analyzer.calculate_market_breadth(
            historical_data, 
            ma_period, 
            history_days
        )
        
        if indicator_data.empty:
            logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å—Å—á–∏—Ç–∞—Ç—å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä")
            return None
        
        logger.info(f"–†–∞—Å—Å—á–∏—Ç–∞–Ω –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –¥–ª—è {len(indicator_data)} –¥–Ω–µ–π")
        
        # –°–æ–∑–¥–∞–Ω–∏–µ –≥—Ä–∞—Ñ–∏–∫–∞ —á–µ—Ä–µ–∑ matplotlib (–±—ã—Å—Ç—Ä–µ–µ)
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))
        fig.patch.set_facecolor('white')
        
        # Bitcoin –≥—Ä–∞—Ñ–∏–∫ - —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º —Å market breadth –¥–∞–Ω–Ω—ã–º–∏
        if 'BTC' in historical_data:
            btc_data = historical_data['BTC'].copy()
            btc_data['date'] = pd.to_datetime(btc_data['date'])
            
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ –∂–µ –¥–∞—Ç—ã —á—Ç–æ –∏ –≤ market breadth –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–µ
            indicator_filtered = indicator_data.tail(history_days)
            if len(indicator_filtered) > 0:
                # –ü–æ–ª—É—á–∞–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω –¥–∞—Ç –∏–∑ market breadth –¥–∞–Ω–Ω—ã—Ö
                mb_start_date = indicator_filtered.index.min()
                mb_end_date = indicator_filtered.index.max()
                
                # –§–∏–ª—å—Ç—Ä—É–µ–º Bitcoin –¥–∞–Ω–Ω—ã–µ –ø–æ —Ç–æ–º—É –∂–µ –¥–∏–∞–ø–∞–∑–æ–Ω—É
                btc_filtered = btc_data[
                    (btc_data['date'] >= mb_start_date) & 
                    (btc_data['date'] <= mb_end_date)
                ].sort_values('date')
                
                if not btc_filtered.empty:
                    ax1.plot(btc_filtered['date'], btc_filtered['price'], 
                            color='#FF6B35', linewidth=2, label='Bitcoin')
                    ax1.set_title('Bitcoin Price (USD)', fontsize=14, fontweight='bold')
                    ax1.set_ylabel('Bitcoin Price (USD)', fontsize=12)
                    ax1.grid(True, alpha=0.3)
        
        # Market breadth –≥—Ä–∞—Ñ–∏–∫ - –∏—Å–ø—Ä–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É –¥–∞—Ç
        indicator_filtered = indicator_data.tail(history_days)
        
        # –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞—Ç –∏–∑ –∏–Ω–¥–µ–∫—Å–∞
        try:
            # –ï—Å–ª–∏ –∏–Ω–¥–µ–∫—Å —É–∂–µ DatetimeIndex
            dates = indicator_filtered.index
            if not isinstance(dates, pd.DatetimeIndex):
                dates = pd.to_datetime(dates)
        except Exception as date_error:
            logger.warning(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞—Ç: {date_error}")
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º —á–∏—Å–ª–æ–≤–æ–π –∏–Ω–¥–µ–∫—Å –∫–∞–∫ fallback
            dates = range(len(indicator_filtered))
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–æ–ª–æ–Ω–∫—É —Å –¥–∞–Ω–Ω—ã–º–∏
        breadth_column = 'percentage_above_ma'
        if 'percentage_above_ma' not in indicator_filtered.columns:
            # –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è –∫–æ–ª–æ–Ω–æ–∫
            possible_names = ['percentage', 'market_breadth', 'breadth', 'above_ma']
            for name in possible_names:
                if name in indicator_filtered.columns:
                    breadth_column = name
                    break
            else:
                # –ë–µ—Ä–µ–º –ø–µ—Ä–≤—É—é —á–∏—Å–ª–æ–≤—É—é –∫–æ–ª–æ–Ω–∫—É
                numeric_cols = indicator_filtered.select_dtypes(include=[float, int]).columns
                if len(numeric_cols) > 0:
                    breadth_column = numeric_cols[0]
        
        ax2.plot(dates, indicator_filtered[breadth_column], 
                color='#2563EB', linewidth=2)
        
        # –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ –∑–æ–Ω—ã —Å –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–º–∏ —Ü–≤–µ—Ç–∞–º–∏
        ax2.axhspan(80, 100, alpha=0.15, color='#FF4757', label='Overbought Zone')
        ax2.axhspan(0, 20, alpha=0.15, color='#2ED573', label='Oversold Zone')
        ax2.axhspan(20, 80, alpha=0.05, color='#57606F', label='Neutral Zone')
        
        # –ü—É–Ω–∫—Ç–∏—Ä–Ω—ã–µ –ª–∏–Ω–∏–∏ –¥–ª—è –≥—Ä–∞–Ω–∏—Ü –∑–æ–Ω
        ax2.axhline(y=80, color='#FF3742', linestyle='--', alpha=0.8, linewidth=2)
        ax2.axhline(y=20, color='#26C059', linestyle='--', alpha=0.8, linewidth=2)
        ax2.axhline(y=50, color='#747D8C', linestyle='-', alpha=0.4, linewidth=1)
        
        # –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ –ø–æ–¥–ø–∏—Å–∏ –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–æ–º (—Å–ª–µ–≤–∞ –æ—Ç –≥—Ä–∞—Ñ–∏–∫–∞)
        ax2.text(0.02, 90, 'OVERBOUGHT', transform=ax2.get_yaxis_transform(), 
                fontsize=11, fontweight='600', color='#FF3742', alpha=0.9,
                bbox=dict(boxstyle='round,pad=0.4', facecolor='white', alpha=0.95, edgecolor='#FF3742', linewidth=1),
                ha='left')
        
        ax2.text(0.02, 10, 'OVERSOLD', transform=ax2.get_yaxis_transform(), 
                fontsize=11, fontweight='600', color='#26C059', alpha=0.9,
                bbox=dict(boxstyle='round,pad=0.4', facecolor='white', alpha=0.95, edgecolor='#26C059', linewidth=1),
                ha='left')
        
        ax2.text(0.02, 50, 'NEUTRAL', transform=ax2.get_yaxis_transform(), 
                fontsize=11, fontweight='600', color='#747D8C', alpha=0.9,
                bbox=dict(boxstyle='round,pad=0.4', facecolor='white', alpha=0.95, edgecolor='#747D8C', linewidth=1),
                ha='left')
        
        ax2.set_title('% Of Cryptocurrencies Above 200-Day Moving Average', 
                     fontsize=14, fontweight='bold', pad=20)
        ax2.set_ylabel('Percentage (%)', fontsize=12)
        ax2.set_xlabel('Date', fontsize=12)
        ax2.set_ylim(0, 100)
        ax2.grid(True, alpha=0.3)
        
        # –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞—Ç –¥–ª—è –æ–±–æ–∏—Ö –≥—Ä–∞—Ñ–∏–∫–æ–≤
        try:
            # –û–¥–∏–Ω–∞–∫–æ–≤–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –æ–±–µ–∏—Ö –ø–∞–Ω–µ–ª–µ–π
            date_formatter = mdates.DateFormatter('%Y-%m')
            month_locator = mdates.MonthLocator(interval=3)
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –æ—Å—å X –Ω–∞ –æ–±–æ–∏—Ö –≥—Ä–∞—Ñ–∏–∫–∞—Ö
            ax1.xaxis.set_major_formatter(date_formatter)
            ax1.xaxis.set_major_locator(month_locator)
            ax1.tick_params(axis='x', rotation=45)
            
            ax2.xaxis.set_major_formatter(date_formatter)
            ax2.xaxis.set_major_locator(month_locator)
            ax2.tick_params(axis='x', rotation=45)
        except Exception as date_error:
            logger.warning(f"–û—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –¥–∞—Ç: {date_error}")
            # –ü—Ä–æ—Å—Ç–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –±–µ–∑ —Å–ª–æ–∂–Ω—ã—Ö –ª–æ–∫–∞—Ç–æ—Ä–æ–≤
            ax1.tick_params(axis='x', rotation=45)
            ax2.tick_params(axis='x', rotation=45)
        

        plt.tight_layout()
        
        # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
        img_buffer = BytesIO()
        plt.savefig(img_buffer, format='png', dpi=150, bbox_inches='tight', 
                   facecolor='white', edgecolor='none')
        img_buffer.seek(0)
        img_bytes = img_buffer.getvalue()
        plt.close(fig)
        
        logger.info("–ë—ã—Å—Ç—Ä—ã–π –≥—Ä–∞—Ñ–∏–∫ —Å–æ–∑–¥–∞–Ω —É—Å–ø–µ—à–Ω–æ")
        return img_bytes
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –±—ã—Å—Ç—Ä–æ–≥–æ –≥—Ä–∞—Ñ–∏–∫–∞: {str(e)}")
        import traceback
        logger.error(f"–ü–æ–ª–Ω–∞—è –æ—à–∏–±–∫–∞: {traceback.format_exc()}")
        return None

def create_matplotlib_chart_from_data(market_data):
    """
    –°–æ–∑–¥–∞–µ—Ç –≥—Ä–∞—Ñ–∏–∫ –∏–∑ –≥–æ—Ç–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞
    """
    try:
        import matplotlib.pyplot as plt
        import matplotlib.dates as mdates
        from io import BytesIO
        import pandas as pd
        
        logger.info("–°–æ–∑–¥–∞–µ–º –≥—Ä–∞—Ñ–∏–∫ –∏–∑ –¥–∞–Ω–Ω—ã—Ö –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞")
        
        indicator_data = market_data['indicator_data']
        
        # –°–æ–∑–¥–∞–Ω–∏–µ –≥—Ä–∞—Ñ–∏–∫–∞
        fig, ax = plt.subplots(1, 1, figsize=(12, 6))
        fig.patch.set_facecolor('white')
        
        # Market breadth –≥—Ä–∞—Ñ–∏–∫
        dates = pd.to_datetime(indicator_data.index)
        
        ax.plot(dates, indicator_data['percentage'], 
                color='#2563EB', linewidth=2)
        
        # –ó–æ–Ω—ã
        ax.axhspan(80, 100, alpha=0.3, color='#FFE4E1')
        ax.axhspan(0, 20, alpha=0.3, color='#F0FFF0')
        ax.axhspan(20, 80, alpha=0.1, color='#F5F5F5')
        
        # –ó–∞–≥–æ–ª–æ–≤–æ–∫ —Å –ø–æ–¥–∑–∞–≥–æ–ª–æ–≤–∫–æ–º
        ax.text(0.5, 1.08, '% Of Cryptocurrencies Above 200-Day Moving Average', 
               transform=ax.transAxes, fontsize=14, fontweight='bold',
               ha='center', va='bottom')
        ax.set_ylabel('Percentage (%)', fontsize=12)
        ax.set_xlabel('Date', fontsize=12)
        ax.set_ylim(0, 100)
        ax.grid(True, alpha=0.3)
        
        plt.tight_layout()
        
        # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
        img_buffer = BytesIO()
        plt.savefig(img_buffer, format='png', dpi=150, bbox_inches='tight', 
                   facecolor='white', edgecolor='none')
        img_buffer.seek(0)
        img_bytes = img_buffer.getvalue()
        plt.close(fig)
        
        logger.info("–ì—Ä–∞—Ñ–∏–∫ –∏–∑ –¥–∞–Ω–Ω—ã—Ö –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞ —Å–æ–∑–¥–∞–Ω")
        return img_bytes
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –≥—Ä–∞—Ñ–∏–∫–∞ –∏–∑ –¥–∞–Ω–Ω—ã—Ö: {str(e)}")
        return None

def create_web_interface_chart():
    """
    –°–æ–∑–¥–∞–µ—Ç –≥—Ä–∞—Ñ–∏–∫ —Ç–æ—á–Ω–æ –∫–∞–∫ –≤ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ —Å Plotly –∏ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç –≤ PNG
    """
    try:
        from crypto_analyzer_cryptocompare import CryptoAnalyzer
        import plotly.graph_objects as go
        from plotly.subplots import make_subplots
        import pandas as pd
        
        # –¢–æ—á–Ω–æ —Ç–∞–∫–∏–µ –∂–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∫–∞–∫ –≤ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ
        top_n = 47
        ma_period = 200
        history_days = 1095  # 3 –≥–æ–¥–∞
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–µ–∑ –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è
        analyzer = CryptoAnalyzer(cache=None)
        
        # –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–æ–ø –º–æ–Ω–µ—Ç –∏ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω–æ–≤
        coins = analyzer.get_top_coins(limit=50)
        if not coins:
            logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –º–æ–Ω–µ—Ç")
            return None
        
        excluded_stablecoins = ['USDT', 'USDC', 'DAI']
        filtered_coins = [coin for coin in coins if coin['symbol'] not in excluded_stablecoins][:top_n]
        
        logger.info(f"–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º {len(filtered_coins)} –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç –∑–∞ {history_days} –¥–Ω–µ–π")
        
        # –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö
        total_days_needed = ma_period + history_days + 50
        historical_data = analyzer.load_historical_data(filtered_coins, total_days_needed)
        
        if not historical_data:
            logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ")
            return None
        
        # –†–∞—Å—á–µ—Ç –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞
        indicator_data = analyzer.calculate_market_breadth(historical_data, ma_period, history_days)
        
        if indicator_data is None or indicator_data.empty:
            logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å—Å—á–∏—Ç–∞—Ç—å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä —à–∏—Ä–∏–Ω—ã —Ä—ã–Ω–∫–∞")
            return None
        
        # –°–æ–∑–¥–∞–Ω–∏–µ subplot –∫–∞–∫ –≤ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ
        fig = make_subplots(
            rows=2, cols=1,
            shared_xaxes=True,
            vertical_spacing=0.1,
            subplot_titles=('Bitcoin Price (USD)', '% Of Cryptocurrencies Above 200-Day Moving Average'),
            row_heights=[0.4, 0.6]
        )
        
        # –ì—Ä–∞—Ñ–∏–∫ Bitcoin (–≤–µ—Ä—Ö–Ω–∏–π)
        if 'BTC' in historical_data:
            btc_data = historical_data['BTC'].copy()
            if 'date' not in btc_data.columns:
                btc_data = btc_data.reset_index()
                if 'timestamp' in btc_data.columns:
                    btc_data['date'] = pd.to_datetime(btc_data['timestamp'])
                else:
                    btc_data['date'] = pd.to_datetime(btc_data.index)
            
            btc_data['date'] = pd.to_datetime(btc_data['date'])
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–æ–ª–æ–Ω–∫—É —Å —Ü–µ–Ω–æ–π
            price_column = 'close'
            if 'close' not in btc_data.columns:
                possible_names = ['Close', 'price', 'Price', 'last', 'Last']
                for name in possible_names:
                    if name in btc_data.columns:
                        price_column = name
                        break
                else:
                    numeric_cols = btc_data.select_dtypes(include=[float, int]).columns
                    if len(numeric_cols) > 0:
                        price_column = numeric_cols[0]
            
            # –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ –ø–µ—Ä–∏–æ–¥—É –∞–Ω–∞–ª–∏–∑–∞
            btc_recent = btc_data.tail(history_days)
            
            fig.add_trace(
                go.Scatter(
                    x=btc_recent['date'],
                    y=btc_recent[price_column],
                    name='Bitcoin',
                    line=dict(color='#f7931a', width=2),
                    showlegend=False
                ),
                row=1, col=1
            )
        
        # –ì—Ä–∞—Ñ–∏–∫ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ (–Ω–∏–∂–Ω–∏–π)
        breadth_column = 'percentage_above_ma'
        if 'percentage_above_ma' not in indicator_data.columns:
            possible_names = ['market_breadth', 'breadth', 'percentage', 'above_ma']
            for name in possible_names:
                if name in indicator_data.columns:
                    breadth_column = name
                    break
            else:
                numeric_cols = indicator_data.select_dtypes(include=[float, int]).columns
                if len(numeric_cols) > 0:
                    breadth_column = numeric_cols[0]
        
        fig.add_trace(
            go.Scatter(
                x=pd.to_datetime(indicator_data.index),
                y=indicator_data[breadth_column],
                name='Market Breadth',
                line=dict(color='#2563EB', width=2),
                showlegend=False
            ),
            row=2, col=1
        )
        
        # –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ –¥–ª—è –∑–æ–Ω
        for y_val, color, label in [(80, "red", "Overbought"), (50, "gray", "Neutral"), (20, "green", "Oversold")]:
            fig.add_hline(y=y_val, line_dash="dash", line_color=color, opacity=0.7, 
                         annotation_text=f"{label} Zone", row=2, col=1)
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –º–∞–∫–µ—Ç–∞ —Ç–æ—á–Ω–æ –∫–∞–∫ –≤ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ
        fig.update_layout(
            title={
                'text': '% Of Cryptocurrencies Above 200-Day Moving Average',
                'x': 0.5,
                'font': {'size': 20, 'color': '#2c3e50'}
            },
            height=700,
            width=1000,
            font=dict(family="Arial", size=12),
            plot_bgcolor='white',
            paper_bgcolor='white',
            margin=dict(l=60, r=60, t=100, b=60)
        )
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ—Å–µ–π
        fig.update_xaxes(gridcolor='lightgray', gridwidth=0.5, showgrid=True)
        fig.update_yaxes(gridcolor='lightgray', gridwidth=0.5, showgrid=True)
        
        # –ü–æ–ø—ã—Ç–∫–∞ —Å–æ–∑–¥–∞—Ç—å PNG —á–µ—Ä–µ–∑ Plotly
        try:
            img_bytes = fig.to_image(format="png", width=1000, height=700, scale=1)
            logger.info("–ì—Ä–∞—Ñ–∏–∫ —Å–æ–∑–¥–∞–Ω —á–µ—Ä–µ–∑ Plotly —É—Å–ø–µ—à–Ω–æ")
            return img_bytes
        except Exception as e:
            logger.warning(f"Plotly –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º matplotlib fallback: {str(e)}")
            return create_matplotlib_fallback_chart(indicator_data, historical_data.get('BTC'), history_days)
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –≥—Ä–∞—Ñ–∏–∫–∞: {str(e)}")
        return None

# –¢–µ—Å—Ç–æ–≤—ã–µ —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã
@app.route('/test-telegram-message', methods=['POST'])
def test_telegram_message():
    """–û—Ç–ø—Ä–∞–≤–∏—Ç—å —Ä–µ–∞–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —Ç–µ—Å—Ç–æ–≤—É—é –≥—Ä—É–ø–ø—É –∏—Å–ø–æ–ª—å–∑—É—è –Ω–∞—Å—Ç–æ—è—â–∏–µ –¥–∞–Ω–Ω—ã–µ"""
    try:
        from telegram_bot import TelegramBot
        from config import TELEGRAM_TEST_CHANNEL_ID
        from scraper import SensorTowerScraper
        from fear_greed_index import FearGreedIndexTracker
        from market_breadth_indicator import MarketBreadthIndicator
        from image_uploader import image_uploader
        
        # –°–æ–∑–¥–∞–µ–º –±–æ—Ç–∞ —Å —Ç–µ—Å—Ç–æ–≤—ã–º –∫–∞–Ω–∞–ª–æ–º
        test_bot = TelegramBot()
        test_bot.channel_id = TELEGRAM_TEST_CHANNEL_ID
        
        # –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –±—ã—Å—Ç—Ä–æ
        scraper = SensorTowerScraper()
        fear_greed = FearGreedIndexTracker()
        market_breadth = MarketBreadthIndicator()
        
        # –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –¥–∞–Ω–Ω—ã–µ
        logger.info("–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è...")
        
        # 1. Coinbase —Ä–µ–π—Ç–∏–Ω–≥
        rankings_data = scraper.scrape_category_rankings()
        if not rankings_data:
            return jsonify({"success": False, "message": "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ Coinbase —Ä–µ–π—Ç–∏–Ω–≥–∞"}), 500
        rankings_message = scraper.format_rankings_message(rankings_data)
        
        # 2. Fear & Greed Index
        fear_greed_data = fear_greed.get_fear_greed_index()
        if not fear_greed_data:
            return jsonify({"success": False, "message": "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ Fear & Greed Index"}), 500
        fear_greed_message = fear_greed.format_fear_greed_message(fear_greed_data)
        
        # 3. Market Breadth —Å –≥—Ä–∞—Ñ–∏–∫–æ–º (–∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–ª–Ω—ã–π —Ä–µ–∂–∏–º —Å 50 –º–æ–Ω–µ—Ç–∞–º–∏)
        market_breadth_data = market_breadth.get_market_breadth_data(fast_mode=False)
        if not market_breadth_data:
            return jsonify({"success": False, "message": "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ Market Breadth"}), 500
            
        # –°–æ–∑–¥–∞–µ–º –≥—Ä–∞—Ñ–∏–∫ –∏ –∑–∞–≥—Ä—É–∂–∞–µ–º
        png_data = create_quick_chart()
        if not png_data:
            return jsonify({"success": False, "message": "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –≥—Ä–∞—Ñ–∏–∫ Market Breadth"}), 500
            
        chart_url = image_uploader.upload_chart(png_data)
        if not chart_url:
            return jsonify({"success": False, "message": "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –≥—Ä–∞—Ñ–∏–∫ –Ω–∞ Catbox"}), 500
            
        # –ü–µ—Ä–µ–≤–æ–¥–∏–º –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π –¥–ª—è —Å—Å—ã–ª–∫–∏
        condition_map = {
            "–ü–µ—Ä–µ–∫—É–ø–ª–µ–Ω–Ω–æ—Å—Ç—å": "Overbought",
            "–ü–µ—Ä–µ–ø—Ä–æ–¥–∞–Ω–Ω–æ—Å—Ç—å": "Oversold", 
            "–ù–µ–π—Ç—Ä–∞–ª—å–Ω–∞—è –∑–æ–Ω–∞": "Neutral"
        }
        english_condition = condition_map.get(market_breadth_data['condition'], market_breadth_data['condition'])
        market_breadth_message = f"Market by 200MA: {market_breadth_data['signal']} [{english_condition}]({chart_url}): {market_breadth_data['current_value']:.1f}%"
        
        # –°–æ–±–∏—Ä–∞–µ–º —Ñ–∏–Ω–∞–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —Ç–æ—á–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–∞
        combined_message = rankings_message
        combined_message += f"\n\n{fear_greed_message}"
        combined_message += f"\n\n{market_breadth_message}"
        
        success = test_bot.send_message(combined_message)
        
        if success:
            return jsonify({
                "success": True, 
                "message": f"–†–µ–∞–ª—å–Ω–æ–µ —Ç–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ {TELEGRAM_TEST_CHANNEL_ID}"
            })
        else:
            return jsonify({
                "success": False, 
                "message": "–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è"
            }), 500
            
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è: {str(e)}")
        return jsonify({
            "success": False, 
            "message": f"–û—à–∏–±–∫–∞: {str(e)}"
        }), 500

@app.route('/test-chart-telegram', methods=['POST'])
def test_chart_telegram():
    """–°–æ–∑–¥–∞—Ç—å –∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–µ—Å—Ç–æ–≤—ã–π –≥—Ä–∞—Ñ–∏–∫ –≤ —Ç–µ—Å—Ç–æ–≤—É—é –≥—Ä—É–ø–ø—É"""
    try:
        from telegram_bot import TelegramBot
        from config import TELEGRAM_TEST_CHANNEL_ID
        from image_uploader import image_uploader
        
        # –°–æ–∑–¥–∞–µ–º –±—ã—Å—Ç—Ä—ã–π –≥—Ä–∞—Ñ–∏–∫ —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
        png_data = create_quick_chart()
        if not png_data:
            return jsonify({
                "success": False, 
                "message": "–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –≥—Ä–∞—Ñ–∏–∫–∞"
            }), 500
        
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –Ω–∞ Catbox
        chart_url = image_uploader.upload_chart(png_data)
        if not chart_url:
            return jsonify({
                "success": False, 
                "message": "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –≥—Ä–∞—Ñ–∏–∫–∞"
            }), 500
        
        # –°–æ–∑–¥–∞–µ–º –±–æ—Ç–∞ —Å —Ç–µ—Å—Ç–æ–≤—ã–º –∫–∞–Ω–∞–ª–æ–º
        test_bot = TelegramBot()
        test_bot.channel_id = TELEGRAM_TEST_CHANNEL_ID
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –≥—Ä–∞—Ñ–∏–∫–æ–º –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ
        test_message = f"üß™ –¢–µ—Å—Ç–æ–≤—ã–π –≥—Ä–∞—Ñ–∏–∫ Market Breadth\n\nMarket by 200MA: üü¢ [Oversold]({chart_url}): 15.2%"
        success = test_bot.send_message(test_message)
        
        if success:
            return jsonify({
                "success": True, 
                "message": f"–ì—Ä–∞—Ñ–∏–∫ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤ {TELEGRAM_TEST_CHANNEL_ID}",
                "chart_url": chart_url
            })
        else:
            return jsonify({
                "success": False, 
                "message": "–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≥—Ä–∞—Ñ–∏–∫–∞"
            }), 500
            
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –≥—Ä–∞—Ñ–∏–∫–∞: {str(e)}")
        return jsonify({
            "success": False, 
            "message": f"–û—à–∏–±–∫–∞: {str(e)}"
        }), 500

@app.route('/test-quick', methods=['POST'])
def test_quick():
    """–ë—ã—Å—Ç—Ä—ã–π —Ç–µ—Å—Ç —Å –≥–æ—Ç–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏"""
    try:
        from telegram_bot import TelegramBot
        from config import TELEGRAM_TEST_CHANNEL_ID
        
        # –°–æ–∑–¥–∞–µ–º –±–æ—Ç–∞ —Å —Ç–µ—Å—Ç–æ–≤—ã–º –∫–∞–Ω–∞–ª–æ–º
        test_bot = TelegramBot()
        test_bot.channel_id = TELEGRAM_TEST_CHANNEL_ID
        
        # –ü–æ–ª–Ω–æ–µ —Ç–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∫–∞–∫ –±—É–¥–µ—Ç –≤ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ
        test_message = """Coinbase: üì± Rank 281
Fear & Greed: üü° Greed (65)
Google Trends: ‚ö™ Low interest
Altcoin Season: üî¥ No altseason (14%)
Market by 200MA: üü¢ [Oversold](https://files.catbox.moe/5mlsdl.png): 15.2%"""
        
        success = test_bot.send_message(test_message)
        
        if success:
            return jsonify({
                "success": True, 
                "message": f"–ë—ã—Å—Ç—Ä–æ–µ —Ç–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ {TELEGRAM_TEST_CHANNEL_ID}"
            })
        else:
            return jsonify({
                "success": False, 
                "message": "–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è"
            }), 500
            
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –±—ã—Å—Ç—Ä–æ–≥–æ —Ç–µ—Å—Ç–∞: {str(e)}")
        return jsonify({
            "success": False, 
            "message": f"–û—à–∏–±–∫–∞: {str(e)}"
        }), 500

@app.route('/quick-test-message')
def quick_test_message():
    """–ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø: –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ—á–∏—â–∞–µ—Ç –∫–µ—à –∏ –∑–∞–≥—Ä—É–∂–∞–µ—Ç —Å–≤–µ–∂–∏–µ –¥–∞–Ω–Ω—ã–µ"""
    try:
        logger.info("=== –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –∫–µ—à–∞ Market Breadth ===")
        
        # –°–æ–∑–¥–∞–Ω–∏–µ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ –±–æ—Ç–∞
        from scheduler import SensorTowerScheduler
        scheduler = SensorTowerScheduler()
        
        # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï 1: –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ —á–∏—Ç–∞–µ–º –ü–û–°–õ–ï–î–ù–ò–ï –¥–∞–Ω–Ω—ã–µ –∏–∑ parsed_ranks.json
        logger.info("–ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ß–∏—Ç–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ parsed_ranks.json")
        from json_rank_reader import get_rank_from_json
        rank = get_rank_from_json()
        if rank is None:
            rank = 'N/A'
        
        # Fear & Greed –¥–∞–Ω–Ω—ã–µ
        from fear_greed_index import FearGreedIndexTracker
        fear_greed_tracker = FearGreedIndexTracker()
        fear_greed_data = fear_greed_tracker.get_fear_greed_index()
        
        # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï 2: Market Breadth –ë–ï–ó –ö–ï–®–ê - —Å–≤–µ–∂–∏–µ –¥–∞–Ω–Ω—ã–µ
        logger.info("–ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ó–∞–≥—Ä—É–∂–∞–µ–º Market Breadth –ë–ï–ó –∫–µ—à–∞")
        market_breadth_data = get_market_breadth_data_no_cache()  # –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è
        
        if market_breadth_data and market_breadth_data.get('status') == 'success':
            breadth_condition = market_breadth_data['data']['condition']
            breadth_percentage = market_breadth_data['data']['percentage']
            breadth_signal = market_breadth_data['data']['signal']
            
            # –°–æ–∑–¥–∞–µ–º –≥—Ä–∞—Ñ–∏–∫ –∏ –ø–æ–ª—É—á–∞–µ–º —Å—Å—ã–ª–∫—É
            chart_link = create_chart_from_web_endpoint()
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–ª–∏–∫–∞–±–µ–ª—å–Ω–æ–π —Å—Å—ã–ª–∫–æ–π –Ω–∞ –≥—Ä–∞—Ñ–∏–∫
            if chart_link:
                market_breadth_message = f"Market by 200MA: {breadth_signal} [{breadth_condition}]({chart_link}): {breadth_percentage}%"
            else:
                market_breadth_message = f"Market by 200MA: {breadth_signal} {breadth_condition}: {breadth_percentage}%"
        else:
            market_breadth_message = "Market by 200MA: ‚ö™ Data unavailable"
        
        # –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –∏—Ç–æ–≥–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
        rank_display = f"Coinbase Appstore Rank: {rank}"
        
        fear_greed_message = fear_greed_tracker.format_fear_greed_message(fear_greed_data) if fear_greed_data else "Fear & Greed: Data unavailable"
        
        # –°–æ—Å—Ç–∞–≤–ª—è–µ–º –ø–æ–ª–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        full_message = f"{rank_display}\n\n{fear_greed_message}\n\n{market_breadth_message}"
        
        # –û—Ç–ø—Ä–∞–≤–∫–∞ –≤ Telegram
        from telegram_bot import TelegramBot
        telegram_bot = TelegramBot()
        success = telegram_bot.send_message(full_message)
        
        if success:
            logger.info("–ò–°–ü–†–ê–í–õ–ï–ù–ù–û–ï –±—ã—Å—Ç—Ä–æ–µ —Ç–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ")
            return jsonify({"status": "success", "message": "–¢–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ"})
        else:
            return jsonify({"status": "error", "message": "–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ Telegram"})
            
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ –ò–°–ü–†–ê–í–õ–ï–ù–ù–û–ú quick_test_message: {str(e)}")
        return jsonify({"status": "error", "message": f"–û—à–∏–±–∫–∞: {str(e)}"})

def get_market_breadth_data_no_cache():
    """–ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø: Market Breadth –ë–ï–ó –∫–µ—à–∞ - –≤—Å–µ–≥–¥–∞ —Å–≤–µ–∂–∏–µ –¥–∞–Ω–Ω—ã–µ"""
    try:
        logger.info("–ó–∞–≥—Ä—É–∂–∞–µ–º Market Breadth –ë–ï–ó –∫–µ—à–∞ - —Ç–æ–ª—å–∫–æ —Å–≤–µ–∂–∏–µ –¥–∞–Ω–Ω—ã–µ")
        
        # –°–æ–∑–¥–∞–Ω–∏–µ –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä–∞ –ë–ï–ó –∫–µ—à–∞
        from crypto_analyzer_cryptocompare import CryptoAnalyzer
        analyzer = CryptoAnalyzer(cache=None)  # –ù–ï–¢ –∫–µ—à–∞!
        
        # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∞–Ω–∞–ª–∏–∑–∞
        ma_period = 200
        history_days = 1096  # 3 –≥–æ–¥–∞ –¥–∞–Ω–Ω—ã—Ö
        
        # –ü–æ–ª—É—á–∞–µ–º —Ç–æ–ø –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç
        top_coins = analyzer.get_top_coins(50)
        if not top_coins:
            logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Ç–æ–ø –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç")
            return None
        
        # –ò—Å–∫–ª—é—á–∞–µ–º —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω—ã
        stablecoins = ['USDT', 'USDC', 'DAI']
        filtered_coins = [coin for coin in top_coins if coin['symbol'] not in stablecoins]
        logger.info(f"–û—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–æ {len(filtered_coins)} –º–æ–Ω–µ—Ç (–∏—Å–∫–ª—é—á–µ–Ω—ã —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω—ã)")
        
        # –ü–†–ò–ù–£–î–ò–¢–ï–õ–¨–ù–û –∑–∞–≥—Ä—É–∂–∞–µ–º —Å–≤–µ–∂–∏–µ –¥–∞–Ω–Ω—ã–µ –ë–ï–ó –∫–µ—à–∞
        total_days_needed = ma_period + history_days + 100
        logger.info("–ü–†–ò–ù–£–î–ò–¢–ï–õ–¨–ù–ê–Ø –∑–∞–≥—Ä—É–∑–∫–∞ —Å–≤–µ–∂–∏—Ö –¥–∞–Ω–Ω—ã—Ö - –∫–µ—à –æ—Ç–∫–ª—é—á–µ–Ω")
        historical_data = analyzer.load_historical_data(filtered_coins, total_days_needed)
        
        if not historical_data:
            logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ")
            return None
        
        # –†–∞—Å—á–µ—Ç –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞
        indicator_data = analyzer.calculate_market_breadth(
            historical_data, 
            ma_period, 
            history_days
        )
        
        if indicator_data.empty:
            logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å—Å—á–∏—Ç–∞—Ç—å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä")
            return None
            
        logger.info(f"–†–∞—Å—Å—á–∏—Ç–∞–Ω –°–í–ï–ñ–ò–ô –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –¥–ª—è {len(indicator_data)} –¥–Ω–µ–π")
        
        # –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
        latest_percentage = float(indicator_data.iloc[-1]['percentage'])
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–∏–≥–Ω–∞–ª –∏ —É—Å–ª–æ–≤–∏–µ
        if latest_percentage >= 80:
            signal = "üî¥"
            condition = "Overbought"
        elif latest_percentage <= 20:
            signal = "üü¢"
            condition = "Oversold"
        else:
            signal = "üü°"
            condition = "Neutral"
        
        return {
            'status': 'success',
            'data': {
                'signal': signal,
                'condition': condition,
                'percentage': round(latest_percentage, 1),
                'current_value': latest_percentage,
                'timestamp': str(indicator_data.index[-1])
            }
        }
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ get_market_breadth_data_no_cache: {str(e)}")
        return None

@app.route('/test-full-message', methods=['POST'])
def test_full_message():
    """–û—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–æ–ª–Ω–æ–µ —Ç–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∫–∞–∫ –≤ –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–µ"""
    try:
        from telegram_bot import TelegramBot
        from config import TELEGRAM_TEST_CHANNEL_ID
        
        # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –∏ –µ–≥–æ –º–µ—Ç–æ–¥ run_now
        global scheduler
        if not scheduler:
            return jsonify({
                "success": False, 
                "message": "–ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω"
            }), 500
        
        # –í—Ä–µ–º–µ–Ω–Ω–æ –º–µ–Ω—è–µ–º –∫–∞–Ω–∞–ª –Ω–∞ —Ç–µ—Å—Ç–æ–≤—ã–π –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        original_channel = scheduler.telegram_bot.channel_id
        scheduler.telegram_bot.channel_id = TELEGRAM_TEST_CHANNEL_ID
        
        # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º –º–µ—Ç–æ–¥ run_now —Å –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–æ–π
        logger.info("–¢–ï–°–¢ –ü–õ–ê–ù–ò–†–û–í–©–ò–ö–ê: –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ —á–µ—Ä–µ–∑ scheduler.run_now()")
        success = scheduler.run_now(force_send=True)
        
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –∫–∞–Ω–∞–ª
        scheduler.telegram_bot.channel_id = original_channel
        
        if success:
            return jsonify({
                "success": True, 
                "message": f"‚úÖ –ü–õ–ê–ù–ò–†–û–í–©–ò–ö –†–ê–ë–û–¢–ê–ï–¢! –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ {TELEGRAM_TEST_CHANNEL_ID}"
            })
        else:
            return jsonify({
                "success": False, 
                "message": "‚ùå –ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –Ω–µ —Å–º–æ–≥ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ"
            }), 500
            
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–∞ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞: {str(e)}")
        return jsonify({
            "success": False, 
            "message": f"‚ùå –û—à–∏–±–∫–∞ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞: {str(e)}"
        }), 500

@app.route('/check-scheduler-status')
def check_scheduler_status():
    """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞ –∏ –≤—Ä–µ–º—è —Å–ª–µ–¥—É—é—â–µ–≥–æ –∑–∞–ø—É—Å–∫–∞"""
    try:
        global scheduler
        if not scheduler:
            return jsonify({
                "status": "error",
                "message": "–ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω"
            })
        
        from datetime import datetime, timezone
        import pytz
        
        # –¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è UTC –∏ MSK
        now_utc = datetime.now(timezone.utc)
        msk_tz = pytz.timezone('Europe/Moscow')
        now_msk = now_utc.astimezone(msk_tz)
        
        # –í—ã—á–∏—Å–ª—è–µ–º —Å–ª–µ–¥—É—é—â–µ–µ –≤—Ä–µ–º—è –∑–∞–ø—É—Å–∫–∞
        next_run_utc = now_utc.replace(hour=8, minute=1, second=0, microsecond=0)
        if next_run_utc <= now_utc:
            next_run_utc = next_run_utc.replace(day=next_run_utc.day + 1)
        
        next_run_msk = next_run_utc.astimezone(msk_tz)
        
        return jsonify({
            "status": "success", 
            "scheduler_running": bool(scheduler),
            "current_time_utc": now_utc.strftime("%Y-%m-%d %H:%M:%S UTC"),
            "current_time_msk": now_msk.strftime("%Y-%m-%d %H:%M:%S MSK"),
            "next_run_utc": next_run_utc.strftime("%Y-%m-%d %H:%M:%S UTC"),
            "next_run_msk": next_run_msk.strftime("%Y-%m-%d %H:%M:%S MSK"),
            "hours_until_next_run": round((next_run_utc - now_utc).total_seconds() / 3600, 1),
            "last_sent_rank": getattr(scheduler, 'last_sent_rank', 'Unknown')
        })
            
    except Exception as e:
        return jsonify({
            "status": "error",
            "message": f"–û—à–∏–±–∫–∞: {str(e)}"
        })

# Set up signal handler for graceful shutdown
signal.signal(signal.SIGINT, signal_handler)

# Initialize scheduler at startup - for both direct run and gunicorn
scheduler_thread = threading.Thread(target=start_scheduler_thread)
scheduler_thread.daemon = True
scheduler_thread.start()
logger.info("Starting scheduler at app initialization")

if __name__ == "__main__":
    # Run the Flask app when called directly
    app.run(host="0.0.0.0", port=5000, debug=True)
